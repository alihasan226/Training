(Home Network password :----------  F24qj3Pl1a) Nokia 6.1


About Andriod :-

Andriod is a mobile operating system developed by google. It is based on a modified version of the linux kernel and other open source software and is designed primarily for touchscreen mobile devices such as smartphone and tablets.
It is developed by Google and later the OHA(Open Handset Alliance)
OHA => it is consortium of 84 companies such as Google,Samsung, AKM, synaptics, KDDI, Germin ,Teleca, Ebay, Intel etc.
It was established on 5th November 2007 led by google. It is committed to advanced open standards provides services and deploy handset using the Andriod Plateform.


The key employes of Andriod Incorporation are Andy Rubin, Rich Miner, Chris White and Nick Sears
Originally intended for ca,era but shifted to smart phones later because of low market for camera only.
Andriod is the nick name of Andy Rubin given by the coworkers because of his love to robots.
In 2007 Google announces the development of Andriod OS
In 2008 HTC launched the first Andriod mobile.
 

Version of Andriod :-
1) Andriod 1.5 Andriod cupcake
2) Andriod 1.6 Andriod Donut
3) Andriod 2.0 Andriod Eclair
4) Andriod 2.2 Andriod Froyo
5) Andriod 2.3 Andriod Gingerbread
6) Andriod 3.0 Andriod Honeycomb
7) Andriod 4.0 Andriod Ice Cream Sandwich
8) Andriod 4.1 to 4.3.1 Andriod Jelly Bean
9) Andriod 4.4 to 4.4.4 Andriod kitKat
10) Andriod 5.0 to 5.1.1 Andriod Lollipop
11) Andriod 6.0 to 6.0.1 Andriod Marshmallow
12) Andriod 7.0 to 7.1 Andriod Nougat
13) Andriod 8.0 to 8.1 Andriod Oreo
14) Andriod 9.0 Andriod Pie


Andriod is written in Java(UI) , C (core), C++ and other

Tools needs to develop the Andriod Application:-
1) Java JDK5 or later version
2) Java Runtime Environment(JRE 6)
3) Andriod Studio


overview :-
Andriod Studio is the official IDE for Andriod application development.
It works based on IntelliJ IDEA

Installation Andriod Studio :-
Before installing Andriod Studio make sure the machine should required installed Java JDK.


once you launched Andriod Studio . its time to mention JDK7 path or later version in andriod studio installer.


1) launched Andriod Studio.exe (make sure machine should requied installed java JDK)

2) mention JDK path or latest version in andriod studio

3) initiating JDK to Andriod Studio

4) check the component which are required to create application (selected Andriod Studio, Andriod SDK, Andriod Virtual Machine and performance intelchip)

5) specify the location of local machine path for Andriod studio and Andriod SDK

6) specify the ram space for Andriod emulator by default it would take 512 MB of local machine

7) final stage it would extract SDK

after finishing installation 

1)open andriod studio project with clicking start a new andriod studio project

2) it will ask for application name, package information and location of project

3) select minimum device your application run on 

4) select the default layout for application

after that it will open development tool
1) to test your andriod application you will need a virtual andriod device

2) to create a Andriod Virtual device Launched Andriod AVD Manager clicking AVD_Manager icon

3) now it will show the default virtual device which are present on your SDK
 or click on Create new Virtual device

 
4) to run the application click Run app or enter shift+f10

Helloworld Example=>
Before writing a hello world code you must know about XML tags . to write hello world code you should redirect to App>res>layout>Activity_main.xml

to show hello world we need to call text view with layout  (about text view and layout you must take reference at Relative Layout and Text View)


Xml stands for Extensible Markup Language. XML tags are not predefined in XML (we must define our own tags).

In Andriod we use xml for designing our layout because xml is lightweight languages so it doesn't make our layout heavy.


what is Andriod Emulator :---------------
An ANdriod Emulator is an ANdriod virtual Device(AVD) that represents a specific Andriod device. You can use an Andriod emulator as a target platform to run and test your Andriod application on your PC.
The emulator lets you prototypes , develop and test Andriod applications without using a physical device.

The Andriod SDK includes a virtual mobile device emulator that runs on your computer.The emulator lets you prototype, develop and test Andriod application without using Physical device.

=> Creating AVD
if you want to emulate a real device first create an AVD with the same device configuration as real device then launched this AVD from AVD manager.

=> Changing Orientation.
usually by default when you launched the emulator its orientation is vertical but you can change it orientation by pressing Ctrl+F11 key from the keyboarcd


Emulator Commands:-----
Apart from just orientation command there are other very useful commands of emulator that you should keep in mind while using emulator.

HOME		shifts to main screen

F2		Toggles context sensitive menu

F3 		Bring call log		

F4		End call

F5		search

F6 		Toggle trackball mode

F7		Power Button

Ctrl+F5		Ring volume up

Ctrl+F6		Ring Volume down


Emulator Sending SMS :----

You can emulate sending SMS to your emulator.
There are two ways to do that. You can do that from DDNS which can be found in ANdriod Studio, or from Telnet (Network utility found in windows).

sending SMS through Telnet.
Telnet is not enabled by default in windows. You have to enable it to use it. Once enabled you can go to command prompt and start telnet by typing telnet.

In order to send SMS , note down the AVD number which can be found on the title bar of the emulator. It could be like this 5554 e.t.c. Once noted , type this command in command prompt.telnet localhost 5554
You will see that you are now connected to your emulator. Now type this command to send message.
sms send 1234 "hello"
Once you type this command , hit enter. Now look at the AVD. You will receive a notification displaying that you got a new text message


Emulator - Making Call
You can easily make phone calls to your emulator using telent client. You need to connect to your emulator from telnet. It is discussed in the sending sms topic above.

After that you will type this command in the telent window to make a call. Its syntax is given below −

gsm call 1234
Once you type this command , hit enter. Now look at the AVD. You will receive a call from the number your put in the command.

Emulator - Transferring files
You can easily transfer files into the emulator and vice versa. In order to do that, you need to select the DDMS utility in Android studio. After that select the file explorer tab.



What are the Feature of Andriod :-------------

Andriod is a powerful operating system competing with apple 4GS and support great features. Few of them are listed below :-
1) Beautiful UI
2) Connectivity
3) Storage (SQLite a lightweight relational database is used for data storage purpose)
4) Media Support
5) Messaging
6) Web browser
7) Multi-Touch
8) Multi-Tasking

What is Widget:------------

A widget is an element of graphics of a graphical user interface(GUI) that display information or provides a specific way for a user to interact with the 
operating system or an application.

Andriod application are usually developed in the java language using Andriod Software Development Kit.
Once developed Andriod application can be packages easily and sold out through a stor such as Google Play Store, Amazon Play Store , Opera Mobile Store.



What is API level?

API Level is an integer value that uniquely identifies the framework API version offered by a version of the Andriod plateform.



User Interface :-
The whole concept of Android User Interface (define using View and ViewGroup) 
A view group is an individual container that organised child views.
one view group can have another view group as an child element.

viewgroup (Linear Layout) contains one Viewgroup (Relative Layout) and two View( Button and TextView) further two more view (EditText) are nested inside


Different XML files Used in Andriod :--
1) Layout XML files
it is used to define the actual UI(User Interface) of out application
It holds all the element(views) or the tools that we want to use in our application like textView Button and other UI


2) Manifest XML file (Manifest.xml)		app>manifest.xml
this xml is used to define all the components of our application.it includes the names of our application packages, our activities, recievers, services and permissions that our application need.
For Example – Suppose we need to use internet in our app then we need to define Internet permission in this file.


3) String xml File(strings.xml)		app>res>values
this xml file is used to replace the Hard-coded string with  a single string.
we define all the string in this xml file then access them in our add(Activity or in Layout XML files)

4)Style xml Files (style.xml)		app>res>values
this xml is used to define different styles and looks for the UI(User Interface) of application

5) Drawable xml files
these are those xml files that are used to provide various graphics to the elements or views of application
is we need to define a gradient color in the background of Buttom or any custom shape for a view then we create a Drawable sml file and set in the background of views.

6) color sml file(colors.xml)
this files are used to define color codes that we used in our app.



Andriod Architecture :-

Andriod operating system is a stack of software component which is roughly divided into five sections and four main layers.

layer1 Linux Kernal

At the bottom of the layers in Linux- Linux 3.6 
this provides a level of abstraction between the device hardware and it contains all the essential hardware drivers like cameras, keyboard, display
the kernal handles all the things that linux is really good at such as networking and a vast array of device drivers which take the pain out of interfacing to perifheral hardware.

layer 2 Libraries

On top of Linux kernel there is a set of libraries including open-source Web browser engine WebKit, well known library libc, SQLite database which is a useful repository for storage and sharing of application data, libraries to play and record audio and video, SSL libraries responsible for Internet security etc.

=> Android Runtime

In Andriod Runtime , there are core libraries and DVM(Dalvik Virtual Machine) which is responsible to run andriod application.
DVM is like JVM it is optimized for mobile device.
It consume less memory and provides fast performance.
 

layer 3 Application Framework

appplication framework layer provides many higher-level services to application in the form of java classes.
Andriod framwork includes the following :-

Activity Manager − Controls all aspects of the application lifecycle and activity stack.

Content Providers − Allows applications to publish and share data with other applications.

Resource Manager − Provides access to non-code embedded resources such as strings, color settings and user interface layouts.

Notifications Manager − Allows applications to display alerts and notifications to the user.

View System − An extensible set of views used to create application user interfaces.


layer 4 Applications
You will find all the Android application at the top layer. You will write your application to be installed on this layer only. Examples of such applications are Contacts Books, Browser, Games etc.




Andriod Application Components:-

Application components are the essential building blocks of an Android application. These components are loosely coupled by the application manifest file AndroidManifest.xml that describes each component of the application and how they interact.


There are following four main components that can be used within Andriod application

1)Activities
They dictate the UI and Handle the User interaction to the smart phone screen 
An activity represent a single screen with a user interface in-short Activity performs actions on the screen.

View => A view is the ui element such as button label text field etc Anything that you see is a view.

Intent => Intent is a message object you can use to request an action from another app component.

2)Services
they handle background processing associated with an application
Servive is background process that can run for a long time.

There are two types of services local and Remote

Local => local service is accessed from within the application

Remote => remote service is accessed remotly from other application running on the same device.

3)Broadcast Receivers
they handle communication between Andriod OS and applications.
=>For example, applications can also initiate broadcasts to let other applications know that some data has been downloaded to the device and is available for them to use, so this is broadcast receiver who will intercept this communication and will initiate appropriate action.


4) Content Providers
Content Provides are used to share data between the applications.
they handle data and database management issues
a content provider component supplies data from one application to other on request.



Additional Components 
1) Fragment
Fragment are like parts of activiy. An activity can display one or more fragments on the screen at the same time.
represent a portion of user interface in an activity

2)view
ui interface that are drawn on-screen including buttonslists forms

3) layout
view hierarchies that controls screen format and appearance of the views

4)Intents
Messages writing component together

5) Resources 
external elements such as string constants and drawable pictures

6) Manifest
configuration file for the application
It contains information about activities content provides permission etc. It is like the web.xml file Java EE.



=> Before you run your app you should be aware of a few directories and files in the Andriod project-

1) Java
This contains the .java source files for your project. By default, it includes an MainActivity.java source file having an activity class that runs when your app is launched using the app icon.
This is the actual application file which ultimately gets converted to a Dalvik executable and runs the application.



2) res/drawable-hdpi

This is a directory for drawable objects that are designed for high-density screens.

3) res/layout

This is a directory for files that define your app's user interface.

4) res/values

This is a directory for other various XML files that contain a collection of resources, such as strings and colours definitions

5) AndroidManifest.xml

This is the manifest file which describes the fundamental characteristics of the app and defines each of its components

Whatever component you develop as a part of your application, you must declare all its components in a manifest.xml which resides at the root of the application project directory. This file works as an interface between Android OS and your application


Following is the list of tags which you will use in your manifest file to specify different Android application components −

<activity>elements for activities

<service> elements for services

<receiver> elements for broadcast receivers

<provider> elements for content providers

4) value
The strings.xml file is located in the res/values folder and it contains all the text that your application uses. For example, the names of buttons, labels, default text, and similar types of strings go into this file. This file is responsible for their textual content.

<resources>
   <string name="app_name">HelloWorld</string>
   <string name="hello_world">Hello world!</string>
   <string name="menu_settings">Settings</string>
   <string name="title_activity_main">MainActivity</string>
</resources>


5) The Layout File
The activity_main.xml is a layout file available in res/layout directory, that is referenced by your application when building its interface. You will modify this file very frequently to change the layout of your application. For your "Hello World!" application, this file will have following content related to default layout 


6) Build.gradle

This is an auto generated file which contains compileSdkVersion, buildToolsVersion, applicationId, minSdkVersion, targetSdkVersion, versionCode and versionName





Accessing Resources Organizing & Accessing :-

Apart from coding for the application you take care of various other resources like static content that your code uses such as bitmaps,colors , layout definitions, user interface string, snimation instructions and more. These resources are always maintained separately in various sub-directoris under res/ directory of the project.


Directory & Resource Type :-

1) anim/
XML file that define property animations. They are saved in res/anim folder and accessed from the R.anim class.

2) color/
XML files that define a state list of colors.

3) drawable/
Image files like .png, .jpg, .gif or XML files that are compiled into bitmaps, state lists, shapes, animation drawable. They are saved in res/drawable/ and accessed from the R.drawable class.

4) layout/

XML files that define a user interface layout. They are saved in res/layout/ and accessed from the R.layout class.

5) menu/

XML files that define application menus, such as an Options Menu, Context Menu, or Sub Menu. They are saved in res/menu/ and accessed from the R.menu class.

6) raw/

Arbitrary files to save in their raw form. You need to call Resources.openRawResource() with the resource ID, which is R.raw.filename to open such raw files.

7) values/

XML files that contain simple values, such as strings, integers, and colors. For example, here are some filename conventions for resources you can create in this directory −

arrays.xml for resource arrays, and accessed from the R.array class.

integers.xml for resource integers, and accessed from the R.integer class.

bools.xml for resource boolean, and accessed from the R.bool class.

colors.xml for color values, and accessed from the R.color class.

dimens.xml for dimension values, and accessed from the R.dimen class.

strings.xml for string values, and accessed from the R.string class.

styles.xml for styles, and accessed from the R.style class.




Accessing Resources :-----
During your application development you will need to access defined resources either in your code, or in your layout XML files.

1) Accessing Resources in Code

When your Android application is compiled, a R class gets generated, which contains resource IDs for all the resources available in your res/ directory. You can use R class to access that resource using sub-directory and resource name or directly resource ID.

To access res/drawable/myimage.png and set an ImageView you will use following code −

ImageView imageView = (ImageView) findViewById(R.id.myimageview);
imageView.setImageResource(R.drawable.myimage);
Here first line of the code make use of R.id.myimageview to get ImageView defined with id myimageview in a Layout file. Second line of code makes use of R.drawable.myimage to get an image with name myimage available in drawable sub-directory under /res.


2) Accessing Resource in xml file
Consider the following resource XML res/values/strings.xml file that includes a color resource and a string resource −

<?xml version="1.0" encoding="utf-8"?>
<resources>
   <color name="opaque_red">#f00</color>
   <string name="hello">Hello!</string>
</resources>
Now you can use these resources in the following layout file to set the text color and text string as follows −

<?xml version="1.0" encoding="utf-8"?>
<EditText xmlns:android="http://schemas.android.com/apk/res/android"
   android:layout_width="fill_parent"
   android:layout_height="fill_parent"
   android:textColor="@color/opaque_red"
   android:text="@string/hello" />




Android - Activities 

Android system initiates its program with in an Activity starting with a call on onCreate() callback method. There is a sequence of callback methods that start up an activity and a sequence of callback methods that tear down an activity as shown in the below Activity life cycle diagram.



callback and description :-

1) onCreate()

This is the first callback and called when the activity is first created.

2) onStart()

This callback is called when the activity becomes visible to the user.

3) onResume()

This is called when the user starts interacting with the application.

4) onPause()

The paused activity does not receive user input and cannot execute any code and called when the current activity is being paused and the previous activity is being resumed.

5) onStop()

This callback is called when the activity is no longer visible.

6) onDestroy()

This callback is called before the activity is destroyed by the system.

7) onRestart()

This callback is called when the activity restarts after stopping it.

Example=>
This file includes each of the fundamental life cycle methods. The Log.d() method has been used to generate log messages −

package com.example.helloworld;

import android.os.Bundle;
import android.app.Activity;
import android.util.Log;

public class MainActivity extends Activity {
   String msg = "Android : ";
   
   /** Called when the activity is first created. */
   @Override
   public void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);
      Log.d(msg, "The onCreate() event");
   }

   /** Called when the activity is about to become visible. */
   @Override
   protected void onStart() {
      super.onStart();
      Log.d(msg, "The onStart() event");
   }

   /** Called when the activity has become visible. */
   @Override
   protected void onResume() {
      super.onResume();
      Log.d(msg, "The onResume() event");
   }

   /** Called when another activity is taking focus. */

   @Override
   protected void onPause() {
      super.onPause();
      Log.d(msg, "The onPause() event");
   }

   /** Called when the activity is no longer visible. */
   @Override
   protected void onStop() {
      super.onStop();
      Log.d(msg, "The onStop() event");
   }

   /** Called just before the activity is destroyed. */
   @Override
   public void onDestroy() {
      super.onDestroy();
      Log.d(msg, "The onDestroy() event");
   }
}







Android - Services :-----

A service is a component that runs in the background to perform long-running operations without needing to interact with the user and it works even if application is destroyed. A service can essentially take two states

1) Started

A service is started when an application component, such as an activity, starts it by calling startService(). Once started, a service can run in the background indefinitely, even if the component that started it is destroyed.


2) Bound

A service is bound when an application component binds to it by calling bindService(). A bound service offers a client-server interface that allows components to interact with the service, send requests, get results, and even do so across processes with interprocess communication (IPC)



The following diagram on the left shows the life cycle when the service is created with startService() and the diagram on the right shows the life cycle when the service is created with bindService():


Callback & Description :--
1) onStartCommand()

The system calls this method when another component, such as an activity, requests that the service be started, by calling startService(). If you implement this method, it is your responsibility to stop the service when its work is done, by calling stopSelf() or stopService() methods.

2) onBind()

The system calls this method when another component wants to bind with the service by calling bindService(). If you implement this method, you must provide an interface that clients use to communicate with the service, by returning an IBinder object. You must always implement this method, but if you don't want to allow binding, then you should return null

3) onUnbind()

The system calls this method when all clients have disconnected from a particular interface published by the service.

4) onRebind()

The system calls this method when new clients have connected to the service, after it had previously been notified that all had disconnected in its onUnbind(Intent).

5) onCreate()

The system calls this method when the service is first created using onStartCommand() or onBind(). This call is required to perform one-time set-up.

6) onDestroy()

The system calls this method when the service is no longer used and is being destroyed. Your service should implement this to clean up any resources such as threads, registered listeners, receivers, etc.







stopService(new Intent(getBaseContext(), MyService.class));

Toast and Intent, both requires reference to context. And getApplication, getApplicationContext, LoginActivity.this and getBaseContext, they all offer reference to the
context.

Now the thing confuses is the declaration of different contexts and their specific-usage. To make things simple, you should count two types of context available in the
Android framework.

1) Application Context

2)Activity Context

Application context is attached to the application's life-cycle and will always be same throughout the life of application. So if you are using Toast, you can use 
application context or even activity context (both) because a toast can be raised from anywhere with in your application and is not attached to a window.


Activity context is attached to the Activity's life-cycle and can be destroyed if the activity's onDestroy() is raised. 
If you want to launch a new activity, 
you must need to use activity's context in its Intent so that the new launching activity is connected to the current activity (in terms of activity stack). 
However, you may use application's context too to launch a new activity but then you need to set flag Intent.FLAG_ACTIVITY_NEW_TASK in intent to treat it as a new task.



Now referring to your cases:

LoginActivity.this though its referring to your own class which extends Activity class but the base class (Activity) also extends Context class, so it can be used to offer activity context.

getApplication() though its referring to Application object but the Application class extends Context class, so it can be used to offer application context.

getApplicationContext() offers application context.

getBaseContext() offers activity context.



	=> Broadcast Receiver :------------

Broadcast Receiver simply respond to broadcast message from other applications or from the system itself.These message are sometime called events or intents.For example application can also initied broadcast to let other application know that
some data has been downloaded to th device and is avialable for them to use,so this is broadcast receiver who will intercept this communication and will 
initiate appropriate action.

There are following two important steps to make BroadcastReceiver works for the system broadcasted intents −

1) Creating the Broadcast Receiver.

2) Registering Broadcast Receiver

=> Creating the Broadcast Receiver
A broadcast receiver is implemented as a subclass of BroadcastReceiver class and overriding the onReceive() method where each message is received as a Intent object parameter.

public class MyReceiver extends BroadcastReceiver {
   @Override
   public void onReceive(Context context, Intent intent) {
      Toast.makeText(context, "Intent Detected.", Toast.LENGTH_LONG).show();
   }
}



=> Registering Broadcast Receiver

An application listens for specific broadcast intents by registering a broadcast receiver in AndroidManifest.xml file. Consider we are going to register MyReceiver
for system generated event ACTION_BOOT_COMPLETED which is fired by the system once the Android system has completed the boot process.

Now whenever your Android device gets booted, it will be intercepted by BroadcastReceiver MyReceiver and implemented logic inside onReceive() will be
executed.

=> Broadcasting Custom Intents
If you want your application itself should generate and send custom intents then you will have to create and send those intents by using the sendBroadcast() method inside your activity class. If you use the sendStickyBroadcast(Intent) method,
 the Intent is sticky, meaning the Intent you are sending stays around after the broadcast is complete.

public void broadcastIntent(View view) {
   Intent intent = new Intent();
   intent.setAction("com.tutorialspoint.CUSTOM_INTENT");
   sendBroadcast(intent);
}

This intent com.tutorialspoint.CUSTOM_INTENT can also be registered in similar way as we have regsitered system generated intent.
<application
   android:icon="@drawable/ic_launcher"
   android:label="@string/app_name"
   android:theme="@style/AppTheme" >
   <receiver android:name="MyReceiver">
   
      <intent-filter>
         <action android:name="com.tutorialspoint.CUSTOM_INTENT">
         </action>
      </intent-filter>
   
   </receiver>
</application>





		Content Provider :--------------
The content provider component supplies data from one application to other on request.
Such request are handle by the methods of the   ===>  ContentResolver <====  class.
Acontent provider can use different ways to store its data and the data can be stored in a database in files or even over a network.

A content provider behaves very much like a database where you can query it, edit its content as well as add or delete content using insert(), update(), delete() and query() methods.
in most cases this data is stored in SQlite database.



	=> A content provider is implemented as a subclass of ContentProvider class and must implement a Standard set of API the enable other application
to perform transaction.

		public class MyApplication extends ContentProvider
		{
		
		}
	

	Content URIs :------------
To query a content provider you specify the query string in the form of a URI which has following format -

<prefix>://<authority>/<data>/<id>


1) prefix		this is always set to centent://


2) authority		this specifies the name of the content provider for example contacts, browser etc for third party content provider this could be fully 
			qualifies name, such as com.tutorialpoint.statusprovider


3) data types		this indicates the type of data that this particular provider provides For example, if you are getting all the contacts from the Contacts 
			content provider, then the data path would be people and URI would look like thiscontent://contacts/people

4) id			This specifies the specific record requested. For example, if you are looking for contact number 5 in the Contacts content provider then URI 
			would look like this content://contacts/people/5.



	=> Create Content Provider :-------------
This involves number of simple steps to create own content provider.

1) First of all you need to create a Content Provider class that extends the ContentProviderbaseclass
2) Second you need to define youe content provider URI address which will be used to access the content
3) Next you will need to create your own database to keep the content .Usually Android uses SQlite database and framework needs to override onCreate() methods which will use SQlite Open Helper method to create or open the provider's database.when your application is launched the onCreate() handler of each of its content provder is called on the main application thread
4) Next you will have to implement Content Provider queries to perform different database specific operations.
5) Finally register your Content Provider in your activity file using <provider> tag

Here is the list of methods which you need to override in Content Provider class to have your Content Provider working −

onCreate() This method is called when the provider is started.

query() This method receives a request from a client. The result is returned as a Cursor object.

insert()This method inserts a new record into the content provider.

delete() This method deletes an existing record from the content provider.

update() This method updates an existing record from the content provider.

getType() This method returns the MIME type of the data at the given URI










	Android Widgets :-------------

There are given a lot of Android widgets with simplified examples such as Buton, EditText, AutoCompleteTextView,ToggleButton, DataPicker,TimePicker,ProgressBar etc.

Android Button =>
Let's learn hoe to perform event handling on button click

Android Toast =>
Display information for short duration of time

Custom Toast =>
we are able to customize the toast such as we can display image on the toast

ToggleButton =>
It has two states ON/OFF

checkBox =>

AlertDialog =>
it display a alert dialog  containing the message with ok and cancelbutton.

Spinner =>
display multiple option but only one can selected at a time.

AutoCompleteTextView =>

RatingBar =>display a rating bar

DatePicker =>
display the datepicker dialog that can be used to pick the date.

timePicker =>
display the timepicker dialog that can be used to pick the time.

Progressbar =>
display progress task.


	AndroidButton :-------------
Android Button represents a push-button. The android.widget.Button is subclass of TextView class and CompoundButton is the subclass of Button class.

There are different types of buttons in android such as RadioButton, ToggleButton, CompoundButton etc.

We can perform action on button using different types such as calling listener on button or adding onClick property of button in activity's xml file.

1)
button.setOnClickListener(new View.OnClickListener() {  
            @Override  
            public void onClick(View view) {  
               //code  
            }  
}); 



2)
<Button  
        android:onClick="methodName"  
/>  




	==> Android title Bar

In this example we are going to explain how to hide the title bar and how to display content in full screen mode

Each activity has an associated window (on which the whole UI draws).
This window has default way of being drawn (whether toolbar , actionbar, icon are drawn or not).
however you can use requestWindowFeature to ask system to include or exclude some of windows features (toolbar,actionbar and so on).


requestWindowFeature(Window.FEATURE_NO_TITLE) method of activity must be called to hide the title
But it must be coded before the setContentView method.

getSupportActionBar() method is used to reterive the instance of ActionBar class. (calling the hide() method of ActionBar class hides the title bar)

=> setFlag() method of Window class is used to display content in full screen mode
you need to pass the WindowManager.LayoutParams.Flag_FullSCREEN contant in the setFlag method.







	=> Android Toast :--------------------------
Toast class is used to show notification for a particular interval of time. After sometime it disappers. It doesn't bloack the user interaction.

Constants of Toast class :-
There are only 2 constant of toast class which are given below.

public statis final int LENGTH_LONG		display view for the long duration of time
public static final int LENGTH_SHORT		display view for the short duation of time.


Methods of Toast class :------------

The widely used methods of Toast class are given below.

Method	Description
public static Toast makeText(Context context, CharSequence text, int duration)			makes the toast containing text and duration.
public void show()										displays toast.
public void setMargin (float horizontalMargin, float verticalMargin)				changes the horizontal and vertical margin difference.






The Basic=====>
First instantiate a Toast object with one of the makeText() methods.
these methods takes three parameter 1)the application Context,2)the text message 3) duration for the toast
you can display a toast  notification with show() methods
	
	Toast toast = Toast.makeText(context, text, duration);
	toast.show();


we can also chain the methods and avoid holding on to the Toast object like this:

	Toast.makeText(context, text, duration).show();

we can change the position of the notification with setGravity(int,int,int) method. these accept three parameter
Gravity constant x position offset and y-position offset.





=> to create a custome layout define a view layout in XML or in application code and pass the root View object to the setView(View) methods.

LayoutInflater inflater = getLayoutInflater();
View layout = inflater.inflate(R.layout.custom_toast,
                (ViewGroup) findViewById(R.id.custom_toast_container));

TextView text = (TextView) layout.findViewById(R.id.text);
text.setText("This is a custom toast");

Toast toast = new Toast(getApplicationContext());
toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
toast.setDuration(Toast.LENGTH_LONG);
toast.setView(layout);
toast.show();

First, retrieve the LayoutInflater with getLayoutInflater() (or getSystemService()), and then inflate the layout from XML using inflate(int, ViewGroup). 
The first parameter is the layout resource ID and the second is the root View. You can use this inflated layout to find more View objects in the layout, 
so now capture and define the content for the ImageView and TextView elements. Finally, create a new Toast with Toast(Context) and set some properties of the toast, 
such as the gravity and duration. Then call setView(View) and pass it the inflated layout. You can now display the toast with your custom layout by calling show()







Android Toast Example :--------------

Toast.makeText(getApplicationContext(),"Hello Javatpoint",Toast.LENGTH_SHORT).show();  

Another code:

Toast toast=Toast.makeText(getApplicationContext(),"Hello Javatpoint",Toast.LENGTH_SHORT);  
toast.setMargin(50,50);  
toast.show();  

Example=>
package example.javatpoint.com.toast;  
  
import android.support.v7.app.AppCompatActivity;  
import android.os.Bundle;  
import android.widget.Toast;  
  
public class MainActivity extends AppCompatActivity {  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
  
        //Displaying Toast with Hello Javatpoint message  
        Toast.makeText(getApplicationContext(),"Hello Javatpoint",Toast.LENGTH_SHORT).show();  
    }  
}  


	
	=> Android Custom Toast Example :-----------------------

you are able to create toast custom toast in android.So you can display some image like congratulation or loss the toast. i means you are able to
customize the toast now.


customtoast.xml
create another xml file inside the layout directory. Here we are having ImageView and TextView in this xml file.
<?xml version="1.0" encoding="utf-8"?>  
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    android:id="@+id/custom_toast_layout"  
    android:orientation="vertical"  
    android:background="#F14E23"  
    >  
  
    <ImageView  
        android:id="@+id/custom_toast_image"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:contentDescription="Hello world"  
        android:src="@drawable/jtp_logo"/>  
  
    <TextView  
        android:id="@+id/custom_toast_message"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:contentDescription="To"  
        android:text="JavaTpoint custom Toast" />  
</LinearLayout>  


	In Activity class MainActivity.java :--------------------------

package example.javatpoint.com.customtoast;  
  
import android.support.v7.app.AppCompatActivity;  
import android.os.Bundle;  
import android.view.Gravity;  
import android.view.LayoutInflater;  
import android.view.View;  
import android.view.ViewGroup;  
import android.widget.Toast;  
  
public class MainActivity extends AppCompatActivity {  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
  
        //Creating the LayoutInflater instance  
        LayoutInflater li = getLayoutInflater();  
        //Getting the View object as defined in the customtoast.xml file  
        View layout = li.inflate(R.layout.customtoast,(ViewGroup) findViewById(R.id.custom_toast_layout));  
  
        //Creating the Toast object  
        Toast toast = new Toast(getApplicationContext());  
        toast.setDuration(Toast.LENGTH_SHORT);  
        toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);  
        toast.setView(layout);//setting the view of custom toast layout  
        toast.show();  
    }  
}










	====> Android ToggleButton Example :----------------------

Android toggle Button can be used to display checked/unchecked (on/off) state on the button.

It is beneficial if user have to change the setting between two state. It can be used to on/off sund,Wifi,Bluetooth etc.

SInce Andriod 4.0 there is another type of toggle button called switch that provides slider control.


 => Android ToggleButton class
ToggleButton class provides the facility of creating the toggle button.


XML Attributes of ToggleButton class

The 3 XML attributes of ToggleButton class.

XML Attribute			Description

android:disabledAlpha		The alpha to apply to the indicator when disabled.
android:textOff			The text for the button when it is not checked.
android:textOn			The text for the button when it is checked.


=> Methods of ToggleButton class

The widely used methods of ToggleButton class are given below.

Method	Description
CharSequence getTextOff()		Returns the text when button is not in the checked state.
CharSequence getTextOn()		Returns the text for when button is in the checked state.
void setChecked(boolean checked)	Changes the checked state of this button.


Example=>
activity_main.xml

<?xml version="1.0" encoding="utf-8"?>  
<android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    xmlns:app="http://schemas.android.com/apk/res-auto"  
    xmlns:tools="http://schemas.android.com/tools"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    tools:context="example.javatpoint.com.togglebutton.MainActivity">  
  
    <ToggleButton  
        android:id="@+id/toggleButton"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:layout_marginLeft="8dp"  
        android:layout_marginTop="80dp"  
        android:text="ToggleButton"  
        android:textOff="Off"  
        android:textOn="On"  
        app:layout_constraintEnd_toStartOf="@+id/toggleButton2"  
        app:layout_constraintStart_toStartOf="parent"  
        app:layout_constraintTop_toTopOf="parent" />  
  
    <ToggleButton  
        android:id="@+id/toggleButton2"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:layout_marginRight="60dp"  
        android:layout_marginTop="80dp"  
        android:text="ToggleButton"  
        android:textOff="Off"  
        android:textOn="On"  
        app:layout_constraintEnd_toEndOf="parent"  
        app:layout_constraintTop_toTopOf="parent" />  
  
    <Button  
        android:id="@+id/button"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:layout_marginBottom="144dp"  
        android:layout_marginLeft="148dp"  
        android:text="Submit"  
        app:layout_constraintBottom_toBottomOf="parent"  
        app:layout_constraintStart_toStartOf="parent" />  
</android.support.constraint.ConstraintLayout>  




MainActivity.java
package example.javatpoint.com.togglebutton;  
  
import android.support.v7.app.AppCompatActivity;  
import android.os.Bundle;  
import android.view.View;  
import android.widget.Button;  
import android.widget.Toast;  
import android.widget.ToggleButton;  
  
public class MainActivity extends AppCompatActivity {  
    private ToggleButton toggleButton1, toggleButton2;  
    private Button buttonSubmit;  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
  
        addListenerOnButtonClick();  
    }  
  
    public void addListenerOnButtonClick(){  
        //Getting the ToggleButton and Button instance from the layout xml file  
        toggleButton1=(ToggleButton)findViewById(R.id.toggleButton);  
        toggleButton2=(ToggleButton)findViewById(R.id.toggleButton2);  
        buttonSubmit=(Button)findViewById(R.id.button);  
  
        //Performing action on button click  
        buttonSubmit.setOnClickListener(new View.OnClickListener(){  
  
            @Override  
            public void onClick(View view) {  
                StringBuilder result = new StringBuilder();  
                result.append("ToggleButton1 : ").append(toggleButton1.getText());  
                result.append("\nToggleButton2 : ").append(toggleButton2.getText());  
                //Displaying the message in toast  
                Toast.makeText(getApplicationContext(), result.toString(),Toast.LENGTH_LONG).show();  
            }  
  
        });  
  
    }  
} 





	Android CheckBox :--------------------------
Android CheckBox is a type of two state button either checked or unchecked.

There can be a lot of usage of checkboxes. For example, it can be used to know the hobby of the user, activate/deactivate the specific action etc.

Android CheckBox class is the subclass of CompoundButton class


=> Methods of CheckBox class
There are many inherited methods of View, TextView, and Button classes in the CheckBox class. Some of them are as follows:

Method						Description
public boolean isChecked()			Returns true if it is checked otherwise false.
public void setChecked(boolean status)		Changes the state of the CheckBox.



In activity_main.xml file we can add checkbox tag to use
<CheckBox  
        android:id="@+id/checkBox"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:layout_marginLeft="144dp"  
        android:layout_marginTop="68dp"  
        android:text="Pizza"  
        app:layout_constraintStart_toStartOf="parent"  
        app:layout_constraintTop_toTopOf="parent" />


we can use it MainActivity.java

package example.javatpoint.com.checkbox;  
  
import android.support.v7.app.AppCompatActivity;  
import android.os.Bundle;  
import android.view.View;  
import android.widget.Button;  
import android.widget.CheckBox;  
import android.widget.Toast;  
  
public class MainActivity extends AppCompatActivity {  
    CheckBox pizza,coffe,burger;  
    Button buttonOrder;  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        addListenerOnButtonClick();  
    }  
    public void addListenerOnButtonClick(){  
        //Getting instance of CheckBoxes and Button from the activty_main.xml file  
        pizza=(CheckBox)findViewById(R.id.checkBox);  
        coffe=(CheckBox)findViewById(R.id.checkBox2);  
        burger=(CheckBox)findViewById(R.id.checkBox3);  
        buttonOrder=(Button)findViewById(R.id.button);  
  
        //Applying the Listener on the Button click  
        buttonOrder.setOnClickListener(new View.OnClickListener(){  
  
            @Override  
            public void onClick(View view) {  
                int totalamount=0;  
                StringBuilder result=new StringBuilder();  
                result.append("Selected Items:");  
                if(pizza.isChecked()){  
                    result.append("\nPizza 100Rs");  
                    totalamount+=100;  
                }  
                if(coffe.isChecked()){  
                    result.append("\nCoffe 50Rs");  
                    totalamount+=50;  
                }  
                if(burger.isChecked()){  
                    result.append("\nBurger 120Rs");  
                    totalamount+=120;  
                }  
                result.append("\nTotal: "+totalamount+"Rs");  
                //Displaying the message on the toast  
                Toast.makeText(getApplicationContext(), result.toString(), Toast.LENGTH_LONG).show();  
            }  
  
        });  
    }  
}  






	Android Custom CheckBox :----------------

Android provides facility to customize the UI of view element rather than default.
you are able to create custom checkbox in android so you can add somw different images of checkbox on the layout.

Example of Custom CheckBox
In this example, we create both default as well as custom checkbox. Add the following code in activity_main.xml file.

in activity_main.xml

<?xml version="1.0" encoding="utf-8"?>  
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    xmlns:app="http://schemas.android.com/apk/res-auto"  
    xmlns:tools="http://schemas.android.com/tools"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    tools:context="example.javatpoint.com.customcheckbox.MainActivity">  
  
  
    <TextView  
        android:id="@+id/textView1"  
        android:layout_width="fill_parent"  
        android:layout_height="wrap_content"  
        android:gravity="center_horizontal"  
        android:textSize="25dp"  
        android:text="Default Check Box"  
        android:layout_alignParentTop="true"  
        android:layout_alignParentLeft="true"  
        android:layout_alignParentStart="true" />  
  
    <CheckBox  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:text="New CheckBox"  
        android:id="@+id/checkBox"  
        android:layout_below="@+id/textView1"  
        android:layout_centerHorizontal="true"  
        android:layout_marginTop="46dp" />  
  
    <CheckBox  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:text="New CheckBox"  
        android:id="@+id/checkBox2"  
        android:layout_below="@+id/checkBox"  
        android:layout_alignLeft="@+id/checkBox"  
        android:layout_alignStart="@+id/checkBox" />  
  
    <View  
        android:layout_width="fill_parent"  
        android:layout_height="1dp"  
        android:layout_marginTop="200dp"  
        android:background="#B8B894"  
        android:id="@+id/viewStub" />  
  
    <CheckBox  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:text="CheckBox 1"  
        android:id="@+id/checkBox3"  
        android:button="@drawable/customcheckbox"  
        android:layout_below="@+id/viewStub"  
        android:layout_centerHorizontal="true"  
        android:layout_marginTop="58dp" />  
  
    <CheckBox  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:text="CheckBox 2"  
        android:id="@+id/checkBox4"  
        android:button="@drawable/customcheckbox"  
        android:layout_below="@+id/checkBox3"  
        android:layout_alignLeft="@+id/checkBox3"  
        android:layout_alignStart="@+id/checkBox3" />  
  
    <TextView  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:textAppearance="?android:attr/textAppearanceSmall"  
        android:textSize="25dp"  
        android:text="Custom Check Box"  
        android:id="@+id/textView"  
        android:layout_alignTop="@+id/viewStub"  
        android:layout_centerHorizontal="true" />  
  
    <Button  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:text="Show Checked"  
        android:id="@+id/button"  
        android:layout_alignParentBottom="true"  
        android:layout_centerHorizontal="true" />  
  
</RelativeLayout>


	Now implement a selector in another file (checkbox.xml) under drawable folder which customizes the checkbox.

 checkbox.xml

<?xml version="1.0" encoding="utf-8"?>  
<selector xmlns:android="http://schemas.android.com/apk/res/android">  
    <item android:state_checked="true" android:drawable="@drawable/checked" />  
    <item android:state_checked="false" android:drawable="@drawable/unchecked"/>  
</selector>  


	In MainActivity.java

MainActivity.java

package example.javatpoint.com.customcheckbox;  
  
import android.support.v7.app.AppCompatActivity;  
import android.os.Bundle;  
import android.view.View;  
import android.widget.Button;  
import android.widget.CheckBox;  
import android.widget.Toast;  
  
public class MainActivity extends AppCompatActivity {  
    CheckBox cb1,cb2;  
    Button button;  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        cb1=(CheckBox)findViewById(R.id.checkBox3);  
        cb2=(CheckBox)findViewById(R.id.checkBox4);  
        button=(Button)findViewById(R.id.button);  
  
        button.setOnClickListener(new View.OnClickListener() {  
            @Override  
            public void onClick(View v) {  
                StringBuilder sb=new StringBuilder("");  
  
                if(cb1.isChecked()){  
                    String s1=cb1.getText().toString();  
                    sb.append(s1);  
                }  
  
                if(cb2.isChecked()){  
                    String s2=cb2.getText().toString();  
                    sb.append("\n"+s2);  
  
                }  
                if(sb!=null && !sb.toString().equals("")){  
                    Toast.makeText(getApplicationContext(), sb, Toast.LENGTH_LONG).show();  
  
                }  
                else{  
                    Toast.makeText(getApplicationContext(),"Nothing Selected", Toast.LENGTH_LONG).show();  
                }  
  
            }  
  
        });  
    }  
} 





	=> Android RadioButton

RadioButton is a two states button which is either checked or unchecked. If a single radio button is unchecked, we can click it to make checked radio
button. Once a radio button is checked, it cannot be marked as unchecked by user.


<?xml version="1.0" encoding="utf-8"?>  
<LinearLayout  
    xmlns:android="http://schemas.android.com/apk/res/android"  
    xmlns:tools="http://schemas.android.com/tools"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    android:orientation="vertical"  
    tools:context="example.javatpoint.com.radiobutton.MainActivity">  
  
    <TextView  
        android:id="@+id/textView1"  
        android:layout_width="fill_parent"  
        android:layout_height="wrap_content"  
        android:layout_marginTop="30dp"  
        android:gravity="center_horizontal"  
        android:textSize="22dp"  
        android:text="Single Radio Buttons" />  
  
  
  
    <!--   Default RadioButtons  -->  
  
    <RadioButton  
        android:id="@+id/radioButton1"  
        android:layout_width="fill_parent"  
        android:layout_height="wrap_content"  
        android:layout_gravity="center_horizontal"  
        android:text="Radio Button 1"  
        android:layout_marginTop="20dp"  
  
        android:textSize="20dp" />  
    <RadioButton  
        android:id="@+id/radioButton2"  
        android:layout_width="fill_parent"  
        android:layout_height="wrap_content"  
        android:text="Radio Button 2"  
        android:layout_marginTop="10dp"  
  
        android:textSize="20dp" />  
  
  
    <View  
        android:layout_width="fill_parent"  
        android:layout_height="1dp"  
        android:layout_marginTop="20dp"  
        android:background="#B8B894" />  
  
    <TextView  
        android:id="@+id/textView2"  
        android:layout_width="fill_parent"  
        android:layout_height="wrap_content"  
        android:layout_marginTop="30dp"  
        android:gravity="center_horizontal"  
        android:textSize="22dp"  
        android:text="Radio button inside RadioGroup" />  
  
  
    <!--   Customized RadioButtons  -->  
  
  
    <RadioGroup  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:id="@+id/radioGroup">  
  
        <RadioButton  
            android:id="@+id/radioMale"  
            android:layout_width="fill_parent"  
            android:layout_height="wrap_content"  
            android:text="  Male"  
            android:layout_marginTop="10dp"  
            android:checked="false"  
            android:textSize="20dp" />  
  
        <RadioButton  
            android:id="@+id/radioFemale"  
            android:layout_width="fill_parent"  
            android:layout_height="wrap_content"  
            android:text="   Female"  
            android:layout_marginTop="20dp"  
            android:checked="false"  
  
            android:textSize="20dp" />  
    </RadioGroup>  
  
    <Button  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:text="Show Selected"  
        android:id="@+id/button"  
        android:onClick="onclickbuttonMethod"  
        android:layout_gravity="center_horizontal" />  
  
  
</LinearLayout>  



=> In java MainActivity.java
RadioButton is generally used with RadioGroup. RadioGroup contains several radio buttons, 
marking one radio button as checked makes all other radio buttons as unchecked


package example.javatpoint.com.radiobutton;  
  
import android.support.v7.app.AppCompatActivity;  
import android.os.Bundle;  
import android.view.View;  
import android.widget.Button;  
import android.widget.RadioButton;  
import android.widget.RadioGroup;  
import android.widget.Toast;  
  
public class MainActivity extends AppCompatActivity {  
    Button button;  
    RadioButton genderradioButton;  
    RadioGroup radioGroup;  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        radioGroup=(RadioGroup)findViewById(R.id.radioGroup);  
    }  
    public void onclickbuttonMethod(View v){  
        int selectedId = radioGroup.getCheckedRadioButtonId();  
        genderradioButton = (RadioButton) findViewById(selectedId);  
        if(selectedId==-1){  
            Toast.makeText(MainActivity.this,"Nothing selected", Toast.LENGTH_SHORT).show();  
        }  
        else{  
            Toast.makeText(MainActivity.this,genderradioButton.getText(), Toast.LENGTH_SHORT).show();  
        }  
  
    }  
}  




	Android Dynamic RadioButton :--------------------

Instead of creating RadioButton through drag and drop from palette, android also facilitates you to create it programmatically (dynamically). For creating dynamic 
RadioButton, we need to use android.view.ViewGroup.
LayoutParams which configures the width and height of views and implements setOnCheckedChangeListener() method of RadioGroup class


 => activity_main.xml
<?xml version="1.0" encoding="utf-8"?>  
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    xmlns:tools="http://schemas.android.com/tools"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    android:paddingBottom="@dimen/activity_vertical_margin"  
    android:paddingLeft="@dimen/activity_horizontal_margin"  
    android:paddingRight="@dimen/activity_horizontal_margin"  
    android:paddingTop="@dimen/activity_vertical_margin"  
    android:id="@+id/relativeLayout"  
    tools:context="com.example.test.dynamicradiobutton.MainActivity">  
  
</RelativeLayout>  



Example=>
package com.example.test.dynamicradiobutton;  
  
import android.support.v7.app.AppCompatActivity;  
import android.os.Bundle;  
import android.widget.RadioButton;  
import android.widget.RadioGroup;  
import android.widget.RelativeLayout;  
  
import android.widget.RelativeLayout.LayoutParams;  
import android.widget.Toast;  
  
public class MainActivity extends AppCompatActivity {  
    RadioGroup rg;  
    RelativeLayout rl;  
    RadioButton rb1,rb2;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
  
        rg = new RadioGroup(this);  
        rl = (RelativeLayout) findViewById(R.id.relativeLayout);  
        rb1 = new RadioButton(this);  
        rb2 = new RadioButton(this);  
  
        rb1.setText("Male");  
        rb2.setText("Female");  
        rg.addView(rb1);  
        rg.addView(rb2);  
        rg.setOrientation(RadioGroup.HORIZONTAL);  
  
        RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams((int) LayoutParams.WRAP_CONTENT,(int)LayoutParams.WRAP_CONTENT);  
        params.leftMargin =150;  
        params.topMargin = 100;  
  
        rg.setLayoutParams(params);  
        rl.addView(rg);  
  
        rg.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {  
            @Override  
            public void onCheckedChanged(RadioGroup group, int checkedId) {  
                RadioButton radioButton = (RadioButton) findViewById(checkedId);  
                Toast.makeText(getApplicationContext(),radioButton.getText(),Toast.LENGTH_LONG).show();  
            }  
        });  
    }  
}  

	



	===> Some Important Points :------------------------

1) android:textColor="hexadecimalcode"  => that is used to change the color of text

2) textSize 
	px => Pixels corresponding to actual pixels on the screen
	in => inches based on the physicalsize of the scrren
	mm => milimeter based on physical size of the screen
	pt => points 1/72 of an inch based on the physical size of the screen
	dp or dip => independent pixels 

3) android:text="name"	it defines the name of the component
4) android:contentdescription="contentof









	==> Android Fragments :--------------

A Fragment is a piece of an activity which enable modular activity design.
It will not to be wroug if we say a fragment is a kind of sub-activity.

Following are important points about fragment :--
=> A fragment has its own layout and its own behaviour with its own life cycle. callbacks.
=> you can add or remove fragment in an activity while the activity is running
=> you can combine multiple fragment in a single activity to build a multi-pane UI.
=> A fragment can be used in multiple activity
=> Fragment life cycle is closely related to life cycle of its host activity means when the activity is paused all the fragment available in the activity will also be stopped
=> Fragment were added to the android API in Honeycomb.

we can create fragment by extending Fragment class and you insert a fragment into your activity layout by declaring in the activity layout file as a
<fragment> element.



	Fragment Life Cycle =>>>>>>>>>

Android fagment life cycle have their own life cycle very similar to an android activity.

1) onAttach()
the fragment instance is associated with an activity instance.the fragment and the activity is not fully initialized. Typically you get in this method a reference to 
 the activity which uses the fragment for further initialization work.

2)onCreate()
The system calls this method when creating the fragment. You should initialize essential components of the fragment that you want to retain when the
 fragment is paused or stopped, then resumed

3)onCreateView()
The system calls this callback when it's time for the fragment to draw its user interface for the first time.
To draw a UI for your fragment, you must return a View component from this method that is the root of your fragment's layout.
You can return null if the fragment does not provide a UI

4)onActivityCreated()
The onActivityCreated() is called after the onCreateView() method when the host activity is created. Activity and fragment instance have been created as well as
 the view hierarchy of the activity. At this point, view can be accessed with the findViewById() method.

5)onStart()
this method in called once the fragment gets visible.
the activity is ready for user interaction.

6)onResume()
Fragment become active
it is used to continue your activity running after previous state.

7) onPause()
The system calls this method as the first indication that the user is leaving the fragment. This is usually where you should commit any changes 
that should be persisted beyond the current user session.

8)onStop()
fragment going to stop by calling onStop()

9)onDestroyView()
fragment view will destroy after call this method

10)onDestroy()
called to the final cleanup of the fragment's state but Not guarntedd to be called by Andriod platform.


 => How to use Fragments?
This involves number of simple steps to create Fragments.

1) First of all decide how many fragments you want to use in an activity. For example let's we want to use two fragments to handle landscape and portrait modes of 
the device.

2) Next based on number of fragments, create classes which will extend the Fragment class. The Fragment class has above mentioned callback functions. 
You can override any of the functions based on your requirements.

3) Corresponding to each fragment, you will need to create layout files in XML file. These files will have layout for the defined fragments.

4) Finally modify activity file to define the actual logic of replacing fragments based on your requirement





	=> Types of Fragments

Basically fragments are divided as three stages as shown below.

Single frame fragments − Single frame fragments are using for hand hold devices like mobiles, here we can show only one fragment as a view.

List fragments − fragments having special list view is called as list fragment

Fragments transaction − Using with fragment transaction. we can move one fragment to another fragment



	Single Frame Fragment :-----------------
Single frame fragment is designed for small screen device such as hand hold device(mobiles) andit should be above android 3.0 version.

Here we will create two fragment and one of them will be used when device is in landscape mode and another fragment will be used in case of portrait mode.










	===> Andriod Intent :--------------------

An Android intent is an abstract description of an operation to be performed.
 It can be used with

startActivity() 	to launched an Activity

broadcastIntent		to send it to any interested BroadcastReceiver component

startService()/bindService(Intent,ServiceConnection,int)	to communicate with a background Service


the intent itself an intent object is a passive data strcuture holding an abstact description of an operation to be performed.

	=> For example, assume that you have an Activity that needs to open URL in a web browser on your Android device. 
For this purpose, your Activity will send ACTION_WEB_SEARCH Intent to the Android Intent Resolver to open given URL in the web browser. 
The Intent Resolver parses through a list of Activities and chooses the one that would best match your Intent, in this case, the Web Browser Activity. 
The Intent Resolver then passes your web page to the web browser and starts the Web Browser Activity.


String q = "tutorialspoint";
Intent intent = new Intent(Intent.ACTION_WEB_SEARCH );
intent.putExtra(SearchManager.QUERY, q);
startActivity(intent);


 It takes you to move from one activity to another activity,we have to two method putExtra(); and getExtra();
putExtra sends a copy of the object



	Methods and Description :------------
Context.startActivity()

The Intent object is passed to this method to launch a new activity or get an existing activity to do something new.

	
Context.startService()
The Intent object is passed to this method to initiate a service or deliver new instructions to an ongoing service.

	
Context.sendBroadcast()
The Intent object is passed to this method to deliver the message to all interested broadcast receivers.



	=> Intent objects:----------------

An intent object is a bundle of informaiton which is used by the component that receives the intent as well as information used by the Android System.

Action :-
This is mandatory part of the intent object and is a string naming the action to be performed or in the case of broadcast intents the action that took place
and is being reported.


The action in an Intent object can be set by the setAction() method and read by getAction()


Data :---
Adds a data specified to an intent filter.The specification can be just a data type (the mime Type attributes), just a URI or both a data type and a URI
A URI is specified by separate attributes for each of its parts-
The setData() method specifies data only as a URI, setType() specifies it only as a MIME type, and setDataAndType() specifiepes it as both a URI and a MIME type. The URI is read by getData() and the type by getType().

Category :---------
The category is an optional part of Intent object and it's a string containing additional information about the kind of component that should handle the
intent. The addCategory() method places a category in an Intent object, removeCategory() deletes a category previously added, and getCategories() gets the set of all categories currently in the object





	=> Types of intent :----------

There are following two types of intent supported by Android:-
1)Explicit type
2)Implicit type


=>Explicit Intent :-

Explicit intent going to be connected internal internal world of application suppose
If you wants to connect one activity to another activity  we can do this by explicit intent.


These intent designate the target component by its name and they are typically used for application-internal message such as an activy stating a subroutine 
or launching a sister activity

//Explicit Tntent by specifying its class name

Intent i = new Intent(FirstActivity.this,SecondActivity.class);

//starts TargetActivity
startActivity(i);


Implicit Intents :---------------
These intnet do not name a target and the field for the component name is left black.
Implicit intent are often used to activate components in other application.





	Intent-Filter :-------------------
You will use <intent-filter> element in the manifest file to list down actions, categories and data types associated with any activity, service, 
or broadcast receiver.


Example of a part of AndroidManifest.xml

<activity android:name=".CustomActivity"
   android:label="@string/app_name">
   
   <intent-filter>
      <action android:name="android.intent.action.VIEW" />
      <action android:name="com.example.My Application.LAUNCH" />
      <category android:name="android.intent.category.DEFAULT" />
      <data android:scheme="http" />
   </intent-filter>
   
</activity>


Once this activity is defined along with above mentioned filters, other activities will be able to invoke this activity using either
the android.intent.action.VIEW, or using the com.example.My Application.LAUNCH action provided their category is android.intent.category.DEFAULT.


The <data> element specifies the data type expected by the activity to be called and for above example our custom activity expects the data to 
start with the "http://"


There are following test Android checks before invoking an activity −

1) A filter <intent-filter> may list more than one action as shown above but this list cannot be empty; a filter must contain at least one <action> 
element, otherwise it will block all intents. If more than one actions are mentioned then Android tries to match one of the mentioned actions before 
invoking the activity.

2) A filter <intent-filter> may list zero, one or more than one categories. if there is no category mentioned then Android always pass this test but 
if more than one categories are mentioned then for an intent to pass the category test, every category in the Intent object must match a category in 
the filter.

3) Each <data> element can specify a URI and a data type (MIME media type). There are separate attributes like scheme, host, port, and path for each 
part of the URI. An Intent object that contains both a URI and a data type passes the data type part of the test only if its type matches a type listed 
in the filter.








		Android UI Layout :--------------------------
The basic building block for user interface is a view object which is created from the view class and occupies a rectangular area on the screen and is responsible
for drawing and event handling.
All Element in the layout are built using hierarchy of View and ViewGroup object.

View usually draws somthing the user can see and interact with
Whereas a viewGroup is an indivisible container that defines the layout strcuture for View and other viewgroup.

view object are usually called widget that are as follow Button,textView
Viewgroup usually called layout that are as follow LinearLayout, RelativeLayout.

	=> Layout Compilation
When you compile app each XML layout file is compiled into a viewresource.
you should load layout resource from your app code in your Activity.onCreate() callback implementation. Do so by calling setContentView() passing
it reference to your layout resource in the form of R.layout.layout-file_name.




Different Types of Layout and Views:----------------

1) Linear Layout
Android LinearLayout is a view group that aligns all children in either vertically or horizontally.


	=> LinearLayout Attributes

android:id 			:--- this is the ID which uniquely identifies the layout
android:baselineAligned		:--- This must be a boolean value, either "true" or "false" and prevents the layout from aligning its children's baselines
android:divider			:--- this is drawable to use as a vertical divider between button you use a color value in the form of #rgb #argb #rrggbb
android:gravity			:--- specifies how an object should position its content on both the X and Y axes
android:orientation		:--- specifies the direction of arrangement


3) Table Layout
Android TableLayout going to be arrange groups of views into rows and columns.
You will use the <TableRow> element to build a row in the table.
Each row has zero or more cells each cell hold one view object.


10:56 AM 9/2/2019

TableLayout Attributes
Following are the important attributes specific to TableLayout −

	Attribute & Description

1) android:id

This is the ID which uniquely identifies the layout.

2) android:collapseColumns

This specifies the zero-based index of the columns to collapse. The column indices must be separated by a comma: 1, 2, 5.

3) android:shrinkColumns

The zero-based index of the columns to shrink. The column indices must be separated by a comma: 1, 2, 5.

4) android:stretchColumns

The zero-based index of the columns to stretch. The column indices must be separated by a comma: 1, 2, 5.



	Absolute Layout :--------------------
An Absolute Layout lets you specify exact locations (x/y coordinates) of its children. Absolute layouts are less flexible and harder to maintain than other types of 
layouts without absolute positioning.


Some of the attributes: -----------

AbsoluteLayout Attributes
Following are the important attributes specific to AbsoluteLayout −

	Attribute & Description

1)android:id
This is the ID which uniquely identifies the layout.

2) android:layout_x
This specifies the x-coordinate of the view.


3) android:layout_y
This specifies the y-coordinate of the view.



	Android List :-----------------
Android LsitView is a view which groups several items and display them in vertical scrollable list. the list items are automatically inserted to the list ueing an Adapter 
that pulls content from a source as an array database.


An adaptor actually bridges between UI component and the data source that fill data into UI component.
Adaptor holds the data and send the data to adaptor view the view can takes the data from adaptor view and showws the data on different views like as
spinner list view grid view .

Listview and gridView are subclasses of AdaptorView and they can be populated by
brigding them to an Adaptor which reterives data from an external source and create a View that represent each data entry.

Android provides several subclasses of Adapter that are useful for retrieving different kinds of data and building views for an AdapterView ( i.e. ListView or GridView).
The common adapters are ArrayAdapter,Base Adapter, CursorAdapter, SimpleCursorAdapter,SpinnerAdapter and WrapperListAdapter. We will see separate examples for both the adapters



	ArrayAdapter adapter = new ArrayAdapter<String>(this,R.layout.ListView,StringArray);

Here are arguments for this constructor −

First argument this is the application context. Most of the case, keep it this.

Second argument will be layout defined in XML file and having TextView for each string in the array.

Final argument is an array of strings which will be populated in the text view.


ListView listView = (ListView) findViewById(R.id.listview);
listView.setAdapter(adapter);

Android ListView is a view which groups several items and display them in vertical scrollable list. The list items are automatically inserted to the 
list using an Adapter that pulls content from a source such as an array or database






	Android Progress Bar using ProgressDialog :-------------------
Progress bars are used to show progress show progress of a task.
Example when you are downloading or uploading something from the internet it is better t show the progress or download/upload to the user

In android there is a class called ProgressDialog that allows you to create progress bar.



	ProgressDialog progress=new ProgressDialog(this);

Now you can set more properties of this dialog such as its style its text


progress.setMessage("Downloading Music :) ");
progress.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
progress.setIndeterminate(true);				//It basically just means you're unsure how long the action will take

	title & description
1
getMax()

This method returns the maximum value of the progress.

2	
incrementProgressBy(int diff)

This method increments the progress bar by the difference of value passed as a parameter.

3	
setIndeterminate(boolean indeterminate)

This method sets the progress indicator as determinate or indeterminate.

4	
setMax(int max)

This method sets the maximum value of the progress dialog.

5	
setProgress(int value)

This method is used to update the progress dialog with some specific value.

6	
show(Context context, CharSequence title, CharSequence message)

This is a static method, used to display progress dialog.





	Android Event Handling :-------------------
Events are useful way to collect data about a user's interaction with interative component of Application. Like Button press or screen touch etc.
Android framework maintain an event queue as first in first out basis.

There are following three concept related to Android Event Management ----------

1) Event Lsitener
An event listener is an interface of View class that contains a single callback method.These methods will be called by the Android framework wheh the View 
to which the listener has been registered is triggered by user interaction with the item in the UI.

2)Event Lsitener Registration
Event registration is the process by which an Event Handler gets registered with an Event Lsitener so that the handler is called when the Event Listener
fires the event.

3) Event Handler
When an Event happens and we have registered an event listener for the event the event listener calls the Event handlers, which is the method actually handles the event.



	Event Listener & Event Handlers :-----------------------

1) Onclick()		OnClickListener()
			This is called when the user either clicks or touches or focuses upon any widget like button, text, image etc.You will use onClick() event handler to handler such event

2) onLongClick()	OnLongClickListener()
			this is called when the user either clicks or touches or focuses upon any widget like button text,image etc for one more second
			you will use onLongClick() event handler to handle such event.


3) onFocusChange()	OnFocusChangeListener()
			This is called when the widget looses its focus ie. user goes away from the view item. You will use onFocusChange() event 
			handler to handle such event.

4) onKey()		OnFocusChangeListener()

			This is called when the user is focused on the item and presses or releases a hardware key on the device. You will use onKey() event handler to handle 
			such event.

5) onTouch()		OnTouchListener()

			This is called when the user presses the key, releases the key, or any movement gesture on the screen. You will use onTouch() 
			event handler  to handle such event.

6) onMenuItemClick	OnMenuItemClickListener()
			This is called when the user selects a menu item. You will use onMenuItemClick() event handler to handle such event

7) onCreateContextMenu() onCreateContextMenuListener()
			  This is called when the content menu is called being built(as the result of a sustained long click)




	Event Listeners Registration :-------------------

Event Registration is the process by which an Event Handler gets registered with an Event Listener so that the handler is called when the Event Listener
fires the event. Though there are several tricky ways to register your event listener for any event, but I'm going to list down only top 3 ways, out of 
which you can use any of them based on the situation.


1) Using an Anonymous Inner Class

2) Activity class implements the Listener interface.

3) Using Layout file activity_main.xml to specify event handler directly.


	Touch Mode :------------

Users can interact with their devices by using hardware keys or buttons or touching the screen.Touching the screen puts the device into touch mode. 
The user can then interact with it by touching the on-screen virtual buttons, images, etc.You can check if the device is in touch mode by calling the 
View class’s isInTouchMode() method


	Focus
A view or widget is usually highlighted or displays a flashing cursor when it’s in focus. This indicates that it’s ready to accept input from the user.

1) isFocusable() − it returns true or false

2) isFocusableInTouchMode() − checks to see if the view is focusable in touch mode. 









		Android -Drag and Drop  :-------------------------
Android drag/drop framework allows your users to move data from one view to another view in the current layout using a graphical drag and drop gesture .
Framework include three important component to support drag and drop functionality --

=> Drag event class
=> Drag listener
=> Helper method and classes



	Drag / Drop Process :--------------
There are basically four steps or states in the drag and drop process :-

1) Started
this event occurs when you start draggin an item in a layout your application calls startDrag() method to tell the system to tell the system to start a drag.
The arguments inside startDrag() method provide the data to be dragged metadata for this data and a callback for drawing the drag shadow.

The syste first reponds by calling back to your application to get a drag shadow.It then displays the drag shadow on th device.Next the system sends drag
event with action type ACTION_DRAG_STARTED to the registered drag event listener for all the View object in the current layout .

To continue to receive drag events including a possible drop event a drag event listener must return true, if the drag event listener returns false then
it will not receive drag events for the current operation until the system sends drag event with action ty[e ACTION_DRAG_ENDED

the user continnue the drag System send ACTION_DRAG_ENTERED action followed by ACTION_DRAG_LOCATION action to the registered drag event listener for the 
View where dragging points enters . The listener may choose to alter its View object's appearence in response to the event or can react by highlighting 
its View.

The drag event listener receive a ACTION_DRAG_EXITED action the user has moved the drag shadow outside the bounding box of the view.

Dropped =>
the user release the dragged item wiht in the bounding box of a view the system sends the view listener a drag event with action type ACTION_DROP

Ended =>
just after the action type ACTION_DROP the system sends out a drag event with action type ACTION_DRAG_ENDED to indicate that the drag operation is over.


The DragEvent Class :----------------
The DragEvent represent an event that is sent out by the system at various times during a drag and drop operation. This class provides few constants
and important methods which we use during Drag/Drop process.






	Following are all constants integers available as a part of DragEvent class. :-------------


1
ACTION_DRAG_STARTED

Signals the start of a drag and drop operation.

2	
ACTION_DRAG_ENTERED

Signals to a View that the drag point has entered the bounding box of the View.

3	
ACTION_DRAG_LOCATION

Sent to a View after ACTION_DRAG_ENTERED if the drag shadow is still within the View object's bounding box.

4	
ACTION_DRAG_EXITED

Signals that the user has moved the drag shadow outside the bounding box of the View.

5	
ACTION_DROP

Signals to a View that the user has released the drag shadow, and the drag point is within the bounding box of the View.

6	
ACTION_DRAG_ENDED

Signals to a View that the drag and drop operation has concluded.



	Methods :------------------

1	
int getAction()

Inspect the action value of this event..

2	
ClipData getClipData()

Returns the ClipData object sent to the system as part of the call to startDrag().

3	
ClipDescription getClipDescription()

Returns the ClipDescription object contained in the ClipData.

4	
boolean getResult()

Returns an indication of the result of the drag and drop operation.

5	
float	getX()

Gets the X coordinate of the drag point.

6	
float getY()

Gets the Y coordinate of the drag point.

7	
String toString()

Returns a string representation of this DragEvent object.



	Listening for Drag Event :------------------

If you want any of your views within a Layout should respond Drag event then your view either implements View.OnDragListener or 
setup onDragEvent(DragEvent) callback method. When the system calls the method or listener, it passes to them a DragEvent object explained above. 
You can have both a listener and a callback method for View object. If this occurs, the system first calls the listener and then defined callback as long as listener returns true.

The combination of the onDragEvent(DragEvent) method and View.OnDragListener is analogous to the combination of the onTouchEvent() and 
View.OnTouchListener used with touch events in old versions of Android

