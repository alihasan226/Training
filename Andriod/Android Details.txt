1:10 PM 9/24/2019 		Recycler View :----------------------

It is also a kind of view group
ViewHolder  - this will hold the view and helps in recycling
 Adapter this will adapt our data so that it can be displayed in a list.


In Android RecyclerView is an advanced and flexible version of ListView and GridView.
It is a continer used for displaying large amount of data sets that can be scrolled very efficiently by maintaining a limited number of views.
It was introduced in Material Design in API level 21 (Android 5.0 Lollipop)

It is an advanced and flexible version of ListView and GridView.
In Recycler view android provides a lot of new features which are not present in existing Listview or GridView.


Important Notes :---------------------
InAndroid RecyclerView provides an ability to implement the horizontal, vertical and Expandable List. it is mainly used when we have data collection whose elements can be change
at runtime based on user action or any network events. For using this wifget we have to specify the Adapter and Layout Manager.


Baisc RecyclerView XML Code :

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="abhiandroid.com.recyclerviewexample.MainActivity">
    
<android.support.v7.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</RelativeLayout>




Gradle Dependency to use RecyclerView :-----------------------------------------------------------------------
The RecyclerView wdiget is a part of separate library for API 7 level or higher. Add the following dependency in your Gradle build file to use recyclerview.


gradleScript >build.gradle and inside dependencies

dependencies {
...
compile "com.android.support:recyclerview-v7:23.0.1"
}


Need of RecycleView in Android :-------------------
Listview /GridView recycle the item layout but don't keep the reference to the layout children forcing us to call findViewById(), for every child of our item layout for every time we call
getView(). This issue causes the scrolling or non reqponsive problem as it frantically tries to gab references to the view's we needed.

RecyclerView still uses Adapter to act as Data source but in this we have to create a ViewHolder to kepp the reference of view in memory so when we need new view it either creates
 a new ViewHolder object to inflate the layout and hold those references or it recycles one from existing stacks.


Component of RecycleView In Andorid: -------------------------------
Mainley used component of RecyclerView

1) Layout Manager
In Android a RecyclerView needs to have a layoutManager and an Adapter to bb instantiated.
It is used to define type of Layout which RecyclerView should use.
It contain the reference of all view  that are filled by the data of the entry.

We can create a Custom Layout Manager by extending RecyclerView.LayoutManager Class but RecyclerView Provides three types of in-built Layout Managers.

1) Linear Layout Manager – It is used for displaying the data items in a horizontal or vertical scrolling List
2) GridLayoutManager – It is used to show the items in grid format
3) StaggeredGridLayoutManager – It is used to show the items in staggered Grid. 


=> LinearLayout manager (Context context)
it is used for displaying the data item in a horizontal or vertical scrolling List.
we use Linearlayout manager for displaying the Recyclerview as a ListView.

public constructor for LinearLayout
LinearLayoutManager(Context context): It is used to create a vertical LinearLayoutManager. In this we need to set only one parameter i.e used to set the context the current Activity.
Example: In below code snippet we show how to use this constructor in Android.


With Default Vertical Orientation:

// get the reference of RecyclerView
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerView);
// set a LinearLayoutManager with default orientation
LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getApplicationContext());
recyclerView.setLayoutManager(linearLayoutManager); // set LayoutManager to RecyclerView


With Horizontal Orientation :---

/ get the reference of RecyclerView
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerView);
// set a LinearLayoutManager with default orientation
LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getApplicationContext());
recyclerView.setLayoutManager(linearLayoutManager); // set LayoutManager to RecyclerView


LinearLayoutManager(Context context, int orientation, boolean reverseLayout): In this first parameter is used to set the current context, second is used to set the Layout Orientation 
should be vertical or horizontal. By using this constructor we can easily create a horizontal or vertical List. Third parameter is a boolean value when set to true layouts from end to start 
it means items are arranged from end to start.

// get the reference of RecyclerView
RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recyclerView);
// set a LinearLayoutManager with default horizontal orientation and false value for reverseLayout to show the items from start to end
LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getApplicationContext(),LinearLayoutManager.HORIZONTAL,false);
recyclerView.setLayoutManager(linearLayoutManager); // set LayoutManager to RecyclerView


GridLayoutManager :--------------------------------------------------
It is used to show the items in grid format. If we need to display items in grid format then we can use GridLayoutManager. In simple words we can say that we use the GridLayoutManager 
for displaying RecyclerView as a GridView.


public constructor for GridLayoutManger :-

GridLayoutManager (Context context, int spanCount): It is used to create a Vertical GridLayoutManager. In this constructor first parameter is used to set the current context and second
parameter is used to set the spanCount means the number of columns in the grid.

With Default Vertical Orientation:
// get the reference of RecyclerView
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerView);
// set a GridLayoutManager with default vertical orientation and 3 number of columns
GridLayoutManager gridLayoutManager = new GridLayoutManager(getApplicationContext(),3);
recyclerView.setLayoutManager(gridLayoutManager); // set LayoutManager to RecyclerView


With Horizontal Orientation:

// get the reference of RecyclerView
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerView);
// set a GridLayoutManager with 3 number of columns
GridLayoutManager gridLayoutManager = new GridLayoutManager(getApplicationContext(),3);
gridLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); // set Horizontal Orientation
recyclerView.setLayoutManager(gridLayoutManager); // set LayoutManager to RecyclerView


GridLayoutManager (Context context, int spanCount, int orientation, boolean reverseLayout): 
In this constructor first parameter is used to set the current context, second parameter is used to set the spanCount means the number of columns in the grid, third parameter is used to
set the Layout Orientation should be vertical or horizontal and last param is a boolean value when sets to true layout from end to start means grids are arranged from end to start.

// get the reference of RecyclerView
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerView);
// set a GridLayoutManager with 3 number of columns , horizontal gravity and false value for reverseLayout to show the items from start to end
GridLayoutManager gridLayoutManager = new GridLayoutManager(getApplicationContext(),3,LinearLayoutManager.HORIZONTAL,false);
recyclerView.setLayoutManager(gridLayoutManager); // set LayoutManager to RecyclerView


=> ViewHolder: 
ViewHolder is used to store the reference of the View’s for one entry in the RecyclerView. A ViewHolder is a static inner class in our Adapter which holds references to the relevant view’s.
By using these references our code can avoid time consuming findViewById() method to update the widgets with new data.



Difference between the Recycler View and ListView :-----------------

1) View Holder
In list view definition view holder was suggested approach for keeping reference for views. But it was not cumpulsion. Althougn by not doing so ListView used show staled data.
ANother major drawback of not using view holder could lead a heavy operation of finding view ids every time which resulted in laggy listview.
 the problem is solved in recycler view by use of RecyclerView.ViewHolder.
This is the major difference in RecyclerView and ListView

2) Layout Manager
3) Item Animation
4) Adapter
5) item Decorator
6) OnItemTouchListener








3:49 PM 9/23/2019
Android ButterKnife library is a view injection library that injects views into android activity / fragments using annotations. For example, @BindView annotation avoids using 
findViewById() method by automatically type casting the view element. Not just view binding, butterknife provides lot of other useful options like binding strings, dimens, drawables, click events and lot more. We’ll see brief about every component 
offered in this article.


---------------------------------------
Pagination  In Reycler View
---------------------------------------
In Android Pagination is very common feature for heavy-data apps today. It's also called endless scrolling or infinite scrolling.
You want to fectch all the data of feed at once and bind with the view , which could-time consuming and your app will appears as running slow.
Pagination is used for better user experience and resource management.
It has broken down a list of content  into equal smaller pieces loaded one at a time.

Pagination (Endless Scrolling or Infinite Scrolling) is a festure common in content-heavy apps. It breaks down a list of content into equal smaller pieces loaded one at a time.
How to implement Pagination with RecyclerView, handle adapter changes with new data, error handling and more.


Why pagination :-------
Pagination allows the user to see the latest content with little wait time and for providing smooth user experience we are used pagination.

Need of Pagination :-------------------------
When you scroll this list and reaches the end of the view more items are loaded.

When Pagination :---------------------
When you have too big content to load that takes a long time to load either from pulling data from database or APIs calls. Then we use pagination.


layoutManager.getChildCount() //visible
layoutManager.getItemCount() //total item in adapter
findFirstVisibleItemPosition() //item that have scrollout

if(visibleitem+scrollout == totalitem) than we get new data












11:53 AM 9/23/2019	 	Retrofit :----------------------------------------------------------------------------------------



It is a type-safe HTTP client for Android and Java.


Retrofit turns your HTTP API into a Java interface.
public interface GithubService{
@GET("user/{user}/repos")
Call<List<Repo>> listRepos(@Path("user") String user);
}

The Retrofit class generates an implementation of the GitHubServices interace
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("https://api.github.com/")
    .build();

GitHubService service = retrofit.create(GitHubService.class);




API Declaration :------------ 
Annotation on the interface methods and its parameters indicate how  a request will be handled.

Request Method :-
Every method must have an Http annotation that provides the request method and relative URL.
There are five built-in annotations GET, POST,  PUT,  DELETE and HEAD



The relative URL of the resource is specified in the annotation.
@GET("user/list")

we can also specify the query parameter in URL.
@GET("user/list?sort=desc")


@GET("/post")
Call<List<Post>> getPost(@Query("userId") int userId)

@GET("posts")
Call<List<Post>> getPosts(@Query("userId") int userId,@Query("_sort") String sort,@Query("_order") String order);

same like as /post?userId&_sort=id&_order=desc


URL Manipulation :---------------
A request URL can be updated dynamically using replacement blocks and paramters on the method .A replacement block is an alphanumeric string surrounded by { and }.
A corresponding parameter must be annotate with @Path using the same string.

@GET("group/{id}/users")
Call<List<User>> groupList(@Path("id") int groupId);

Query parameters can also be added.

@GET("group/{id}/users")
Call<List<User>> groupList(@Path("id") int groupId, @Query("sort") String sort);


For complex query parameter combinations a Map can be used.

@GET("group/{id}/users")
Call<List<User>> groupList(@Path("id") int groupId, @QueryMap Map<String, String> options);
Here we can put the userId in the MainActivity directly



REQUEST Body :----------
 An object can be specified for use as an HTTP request body with the body annotaion
@POST("users/new")
Call<User> createUser(@Body User user);

The @Body annotation defines a single request body.
The object will also be converted using a converter specific on the Retrofit instance. If no converter is added only RequestBody can be used.



FORM ENCODED AND MULTIPART
Methods can also be declared to send form-encoded and multipart data.

Form-encoded data is sent when @FormUrlEncoded is present on the method. Each key-value pair is annotated with @Field containing the name and the object providing the value.

@FormUrlEncoded
@POST("user/edit")
Call<User> updateUser(@Field("first_name") String first, @Field("last_name") String last)

The @Body annotation defines a single request body.

@MULTIPART
Multipart requested are used when @Multipart is present on the method . Parts are declared using the @Part annotation.
@Multipart
@PUT("user/photo")
Call<User> updateUser(@Part("photo") RequestBody photo, @Part("description") RequestBody description);

Multipart parts use one of Retrofit's converters or they can implement RequestBody to handle their own serialization.





PUT / PATCH / DELETE :---------------
these are applied for a single item

Put and Patch both are used for updating the existing resource

PUT=> Completely replace the existing resource with one we send over

PATCH=> If we don't send any request to the server it doesnot get the null value it will fit the default value that have already been added.


HTTP defines a set of request method to indicate the desired action to be performed for a given resource.

GET
the GET method request a representation of the specific resource. Request using GET should only reterive data.

HEAD
the HEAD method asks for a response identical to that of a GET request but without the reqponse body.

POST
the POST method is used to submit an  entity to the specified resource, often causing a change in state or side effects on the server.

PUT
The PUT method replaces all current representations of the target resource with the request payload

DELETE
The DELETE method deletes the specified resource.


FORM ENCODED AND MULTIPART
methods can also be declare to send form-encoded and multipart data.
form-encoded data is sent when @FormUrlEncoded is present on the method
Each key-value apir annotated with @Field containing the name and the obejct providing the value.

@FormUrlEncoded
@POST("user/edit")
Call<User> updateUser(@Field("first_name") String first, @Field("last_name") String last);



If we want to get the set the Query with the REQUEST method than we can out that in 
@GET("posts")//Here we declare the relative URL
    Call<List<Post>> getPost(@Query("userId") int userId,
                             @Query("_sort")    String sort,
                             @Query("_order")   String order
    );

Here we have the Request method and the relative url  that is post 

to fit the Query we have enter the  \\@Query("user_Id) int userId, @Query("_sort")    String sort,  @Query("_order")   String order  
so this is query and we can set the paramter of the query in the MainActivity class  Call<List<Post>> call=jsonplaceholder.getPost(2,"id","desc");

If we want to get the more than two Query means to say that want to get the userId of  two person than we can get by using 

 @GET("posts")//Here we declare the relative URL
    Call<List<Post>> getPost(@Query("userId") Integer userId,
                             @Query("userId") Integer userId1,
                             @Query("_sort")    String sort,
                             @Query("_order")   String order
    );



2nd method
 @GET("posts")//Here we declare the relative URL
    Call<List<Post>> getPost(@Query("userId") Integer[],
                             @Query("_sort")    String sort,
                             @Query("_order")   String order
    );


we can also put the data in the form key and value pair  using Map<>

    @GET("posts")//Here we declare the relative URL
    Call<List<Post>> getPost(@QueryMap Map<String,String> parameters);


in MainActivity class we can use

 Map<String,String> parameter=new HashMap<>();
        parameter.put("userId","1");
        parameter.put("_sort","id");
        parameter.put("_order","desc");

        Call<List<Post>> call=jsonplaceholder.getPost(parameter);



we cal also use more complex relative url so for that we can use the
   @GET
    Call<List<PostComment>> getComment(@Url String url);

and in MainActivity paramter we can pass the "relative url "





POST is another kind of the Request method  that is used for the send data to the server.
 we will perform on the /posts end point 

@POST("posts")
Call<Post> createPost(@Body Post post);
in this we serializing the post object into Json format than we put it to HTTP body


@FORMUrlEncoded
@POST
Call<Post> createPost(@Feild





What is Network transaction?
In computer programming a transaction usually means a sequence of information exchange and related work.


=> RESTful API
REST stands for Representational state Transfer(REST) Technology
A RESTful API is an application program interface (API) that uses HTTP requests to GET, PUT, and DELETE data.



=> How RESTful APIs work
A RESTful API breaks down a transaction to create a series of small modules. Each modules adddresses a particular underlying part of the transaction.
This modularity provides developers with a lot of flexibility but it can be challenging for developer to design from scratch.
Currently the models provides by AmazonS3, Cloud DataManagement interface (CDMI) and OpenStack Swift are the most popular.

A RESTful API explicitly takes advantage of HTTP methodologies defined by the RFC 2616 protocol. 

GET to reterieve a resource; 
PUT to change the state of or update aresource, which can be an object, file or block; 
POST to create that resource;
DELETE to remove it.

In Android Retrofit is a REST Client for java and android by Square inc under Apache 2.0 license.Its a simple network library that used for network transaction.
By using this library we can seamlessly capture JSON reponse from web service/web API.
it's easy and fast library to reterive and upload the data (JSON or any other structured data) via a REST based web service.

JSON :  Javascript Object Notation
JSON is a syntax for storing and exchanging data
JSON is text wtitten with JavaScript object notation

When exchanging data between a browser and a server the data can only be text.
JSON is text and we can convert any JavaScript into JSON and send JSON to the server.
we can also convert any JSON received from the server into JavaSript objects.
this way we can work with the data.

That is used to fetch and send the data from/to server.
Retrofit is better alternative of other libraries in term of performance, ease of use , extensibility and others.

In Android retrofit library is different from other network libraries because it gives us an easy to use platform through which we don't need to parse JSON responce as they are done 
by libraries itself.It used GSON library in the background to parse the response data. what we need to so is define a POJO (Plain Old Java Object) to parse the response.



POJO / Model Class :-------
For fetching response we need to create POJO class that automatically parse the JSON data using GSON in background. We just need to create this POJO class. For creating POJO class
first method is defining each and every variable by ourself

second best and fast method is using http://www.jsonschema2pojo.org/ platform. By using this platform you can easily convert your JSON response to POJO class.
for this we need to copy our JSON response and paste it in jsonschema2pojo and it will create setter getter methods as per our requirement.


API Key Name => alihasanapi
APIkey => ng0GJouUXk1zNw0xTEzbzN3WMpd7xeIE
Fullcontact.com


Sample POJO class:

public class SamplePojo {

private int userId;
private String name;

public int getUserId() {
return userId;
}

public String getName() {
return name;
}
}



API Interface :-----------
Now we need to create an interface to define our different method that will be used for network transactions.
public interface ApiInterface {


// For POST request

    @FormUrlEncoded    // annotation that used with POST type request
    @POST("/demo/login.php") // specify the sub url for our base url
    public void login(
            @Field("user_email") String user_email,
            @Field("user_pass") String user_pass, Callback<SignUpResponse> callback); 

//user_email and user_pass are the post parameters and SignUpResponse is a POJO class which recieves the response of this API


// for GET request

    @GET("/demo/countrylist.php") // specify the sub url for our base url
    public void getVideoList(Callback<List<CountryResponse>> callback);

// CountryResponse is a POJO class which receives the response of this API

}

 







RestAdapter :------------------
We need to define RestAdapter to implement API's. Suppose we have to implement login API then we need to build RestAdapter, setting root url and create connection between our
adapter and API interface. for this its  better to create a class in which we have a method that create the connection and then return the API interface object.
You can create this RestAdapter where you want to implement API but its better to create a common class/method and use it where you want.

 public class Api {

    public static ApiInterface getClient() {

        RestAdapter adapter = new RestAdapter.Builder()
                .setEndpoint("http://healthyblackmen.org") //Setting the Root URL
                .build(); //Finally building the adapter

        //Creating object for our interface
        ApiInterface api = adapter.create(ApiInterface.class);
        return api;
    }
}




First things we have to find an adequate web API from which to fetch data . After a fair bit of hunting  we settled on FullContactPerson API. This is an excellent and interesting API.
It takes a person's email address and them returns information about the person from over120 different social netowks, including facebook twitter and linkedin.
The return information can be in either XML or JSON.
Like most API's you need an API key which must be specifies with every API

LoggingInterceptor :--------------------------------------
Retrofit integrate a log feature for basic request and response debugging.The logging functionality was removed in Retrofit 2 since the required HTTP layer is now completely 
based on OkHttp. Since many developer asked for logging capabilities in Retrofit 2 the developer of OkHttp addes a logging interceptor in release 2.6.0.

Retrofit 2 compltely relies on OkHttp for any network operation.The developer of OkHttp released a separate logging interceptor project which implements logging for OkHttp.
You can add it to your project with quickly edit of your  build.gradle.

while developing your app and for debugging purpose it's nice to have a log feature intergrated to show request and response information .Since logging isn't ite




OkHttp Android :--------------------
Initially Android has only two HTTP client HttpURL Connection and Apache HTTP Client for sending and receiving data from the web . Each of these client requied a lot of coding inside it.
It having various limitation when it come to cancelling an HTTP request or connection-pooling.


















12:49 PM 9/20/2019 Animation in Android :--------------------------
Animation can add visual cues that notify users about what's going on in your app. They are especially useful when the UI changes state such as when content loads or new action
become available. Animaiton also add a polished look to your app, which gives it a higher quality look and feel.
Android includes different animation APIs depending on what type of animation you want.



Animation bitmaps :-------------------
When you want to animate a bitmap graphic such as an icon or illustration you should use the drawable animation APIs. Usually these animation are defined statically with drawable
resource but you can  also define the animation behaviour at runtime.



Animation UI visibility and motion :------------------------
When you need to change the visibility or position of views in your layout you should include animations to help the user understand how the UI is changing.
To move releat or hide views with in the current layouot you can use the property animation system provided by the 
	android.animation package available in andorid 3.0 (ApI Level 11) and higher
These APIs updated the properties of your View objects over a period of time , continuously redrawing the view as the properties change. for example whe you change the position properties
 the view moves across the screen , or when you change the alpha property the view fades in or out.




7:18 PM 9/20/2019 Floating Action Button :------------------------


10:41 AM 9/20/2019 TextInputLayout :-
To implement the textinputlayout in your android project you have to make some changes in your Gradle Scripts (build.gradle (Module:app)) 

    implementation 'com.android.support:appcompat-v7:29.0.0'
    implementation 'com.android.support:design:29.0.0'

these two implementation will have to added in your dependencies section


 





4:10 PM 9/18/2019
TextUtils :------------------------------------
It is simply a set of utility functions to do operations onString objects. In fact the whole class doesn't have any instance fileds or methods. Everything is static Container it like a container to group
function with a text-based semantic. Many of them could have been methods of string inherited class or Charsequence inherited class.

	For example you can do :-
TextUtils.indexOf(string,char)




ArrayAdapter :-------------------------
You can use this adapter to provide views for an AdapterView Returns a view for each object in a collection of data object you provides you provides and can be used with list-based user interface
widget such as ListView or Spinner.

By default the array adapter creates a view by calling Object#toString() Returns a view for each objet in a collection you provides and places the result in a TextView .
You may also customize what type of view is used for the data object in the collection.
To customize what type of view is used for the data object override getView(int, android.view.View,android.view.ViewGroup) and inflate a view resource.




Spinner :-----------------------------------
Spinner provides a quick way to select one value from a  set. In the default state a spinner shows its currently selected value. Touching the spinner displays a dropdown menu with all the 
other available values from which the user can select a new one.

You can add spinner to your layout with the spinner object. You should usually os do in your XML layout with a Spinner element





DatePickerDialog :-----------------------------------------
Android  Date Time Picker are  used a lot in android apps. These components are used to select date and time ina customised user interface. we will use DatePickerDialog
classes with calender class in our android application code to achiene this.

public DatePickerDialog(Context context, DatePickerDialog.OnDateSetListener listener, int year, int month, int dayofmonth)
creates a new date picker dialog for the sprcified date using the parent context's default date picker theme.

Parameter :-------------------

context		:--			context the parent context this value must never br null
listener		:--			DatePickerDialog.OnDateSetListener the listener to call when the user sets the date this value may be null.
year		:-- 			int the initially selected year
month		:--			int the initially selected month (0-11 for compatibility withh Calender#month)
dayofmonth	:--			the initially selected day of month (1-31 depending on the month)









App Manifest Overview :---------------------------

Every app project must have an AndroidManifest.xml file(with precisely that name) at the root of the project source set.The Manifest declare the essential information about your app to the
Android build tools Android operating system and Google play.


Among many other things the manifest file is required to declare the following: -----------

1) The app's package name which usually matches your code's namespace. The Android build tools use this to determine the location of code entitied when building your project.
When packaging the app the build toolls replace this value with the application ID from the Gradle build files, which is used as the unique app identifier on the system and on Google play.

xmlns:android
Defines the Android namespace . This attributes ahould always be set to  "http://schemas.android.com/spk/res/android".
xmlns:android is for identification that this xml is used for android not for other function.
Namespaces uniquely identify code/libraries if i write an api that uses all the same names and such as the android api the only way to distinguish between my api and android api to use the
android namespace or mine.

2) The components of the app, which include all activities, services, broadcast receivers, and content providers. Each component must define basic properties such as the name of its
Kotlin or Java class. It can also declare capabilities such as which device configurations it can handle, and intent filters that describe how the component can be started

3) The permissions that the app needs in order to access protected parts of the system or other apps. It also declares any permissions that other apps must have if they want to access
 content from this app.

4) The hardware and software features the app requires which affects which devices can install the app from Google play.


File Featues :---------------
The manifest file's root element requires an attribute for your app's package name
For example the following snippet shows the root <manifest> element with the package name "com.example.myapp"
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp"
    android:versionCode="1"
    android:versionName="1.0" >
    ...
</manifest>


while building your app into final application package (APK) the android build use the package attribute for two things :

1) It applies this name as the namespace for your app's generated R.java class (used to access your app resource)
Example with the above manifest the R class is created at com.example.myapp.R

2) It uses this name to resolve any relative class name that are declared in the manifest file
Example : with the above manifest an activity declared as <activity android:name=".MainActivity"> is resolved to be com.example.myapp.MainActivity.

App Components :---------------
For each app component that you create in your app you must declare a corresponding XML element in ht emanifest file:

<activity> for each subclass of Activity
<service> for each subclass of serivce
<receiver> for each subclass of service
<provider> for each subcalss of Content provider


If you subclass any of these component without declaring it in the manifest file the system cannot start it.
The name of your subclass must be specified with the name attribute, using the full package designation. For example, an Activity subclass can be declared as follows:

<manifest ... >
    <application ... >
        <activity android:name="com.example.myapp.MainActivity" ... >
        </activity>
    </application>
</manifest>


However, if the first character in the name value is a period, the app's package name (from the <manifest> element's package attribute) is prefixed to the name. 
For example, the following activity name is resolved to `"com.example.myapp.MainActivity"`:

<manifest package="com.example.myapp" ... >
    <application ... >
        <activity android:name=".MainActivity" ... >
            ...
        </activity>
    </application>
</manifest>

If you have app components that reside in sub-packages (such as in com.example.myapp.purchases), the name value must add the missing sub-package names 
(such as ".purchases.PayActivity") or use the fully-qualified package name.


Intent filters
App activities, services, and broadcast receivers are activated by intents. An intent is a message defined by an Intent object that describes an action to perform, 
including the data to be acted upon, the category of component that should perform the action, and other instructions.

An app component can have any number of intent filters (defined with the <intent-filter> element), each one describing a different capability of that component.


=> Icons and labels
A number of manifest elements have icon and label attributes for displaying a small icon and a text label, respectively, to users for the corresponding app component.

In every case, the icon and label that are set in a parent element become the default icon and label value for all child elements.
 For example, the icon and label that are set in the <application> element are the default icon and label for each of the app's components (such as all activities).



The icon and label that are set in a component's <intent-filter> are shown to the user whenever that compoennt is presented as an option to funfill an intent.
By default this icon is inherited from which ever icon is declared for the parent component but  you might want to change the icon for an intent filter if it provides a unique action that you would
like to better indicate in the chooser dislog.



=> Permissions
Android apps must request permission to access sensitive user data (such as contacts and SMS) or certain system features (such as the camera and internet access). 
Each permission is identified by a unique label. For example, an app that needs to send SMS messages must have the following line in the manifest:

<manifest ... >
    <uses-permission android:name="android.permission.SEND_SMS"/>
    ...
</manifest>

Beginning with Android 6.0 (API level 23), the user can approve or reject some app permisions at runtime. But no matter which Android version your app supports,
you must declare all permission requests with a <uses-permission> element in the manifest. If the permission is granted, the app is able to use the protected features.
If not, its attempts to access those features fail


=> Device compatibility
The manifest file is also where you can declare what types of hardware or software features your app requires, and thus, which types of devices your app is compatible with. 
Google Play Store does not allow your app to be installed on devices that don't provide the features or system version that your app requires.

=> <uses-sdk>
Each successive platform version often adds new APIs not available in the previous version. To indicate the minimum version with which your app is compatible,
your manifest must include the <uses-sdk> tag and its minSdkVersion attribute.

However, beware that attributes in the <uses-sdk> element are overridden by corresponding properties in the build.gradle file. So if you're using Android Studio,
you must specify the minSdkVersion and targetSdkVersion values there instead:

android {
  defaultConfig {
    applicationId 'com.example.myapp'

    // Defines the minimum API level required to run the app.
    minSdkVersion 15

    // Specifies the API level used to test the app.
    targetSdkVersion 28

    ...
  }
}



=> <uses-feature>
The <uses-feature> element allows you to declare hardware and software features your app needs. For example, if your app cannot achieve basic functionality on a device
without a compass sensor, you can declare the compass sensor as required with the following manifest tag

<manifest ... >
    <uses-feature android:name="android.hardware.sensor.compass"
                  android:required="true" />
    ...
</manifest>

What is Compass sensor ?
The digital compass that's usually based on a sensor called the magnetometer and provides mobile phones with a simple orientation in relation to the Earth's magnetic field.
 As a result, your phone always knows which way is North so it can auto rotate your digital maps depending on your physical orientation.


=> File Conventions :--------------

1) Elements
Only the <manifest> and <application> elements are required. They each must occur only once. Most of the other elements can occur zero or more times. However, some of them must be
 present to make the manifest file useful.

All of the values are set through attributes, not as character data within an element.

Elements at the same level are generally not ordered. For example, the <activity>, <provider>, and <service> elements can be placed in any order. 
There are two key exceptions to this rule:

An <activity-alias> element must follow the <activity> for which it is an alias.
The <application> element must be the last element inside the <manifest> element.


=> Multiple values
If more than one value can be specified, the element is almost always repeated, rather than multiple values being listed within a single element. For example, an intent filter can list several actions:
<intent-filter ... >
    <action android:name="android.intent.action.EDIT" />
    <action android:name="android.intent.action.INSERT" />
    <action android:name="android.intent.action.DELETE" />
    ...
</intent-filter>







=> <action>
syntax :-

	<action android:name="string"/>

contained in:
	<intent-filter>

description :
Adds an action ot an internt filter. An <intent-filter> element must contain one or more <action> elements.
If there are not <action>element in an intent fileter the filter doesn't accept any intent object 

attribute :
	android:name
	The name of the action some standard actions are defined in the Intent class as
	ACTION_string constants to assign one of these actions to this attribute prepend
	"android.intnet.action. "to the string that follow ACTION_
	For example for ACTION_MAIN use "android.intent.action.MAIN"




=> <activity>

<activity android:allowEmbedded=["true" | "false"]
          android:allowTaskReparenting=["true" | "false"]
          android:alwaysRetainTaskState=["true" | "false"]
          android:autoRemoveFromRecents=["true" | "false"]
          android:banner="drawable resource"
          android:clearTaskOnLaunch=["true" | "false"]
          android:colorMode=[ "hdr" | "wideColorGamut"]
          android:configChanges=["mcc", "mnc", "locale",
                                 "touchscreen", "keyboard", "keyboardHidden",
                                 "navigation", "screenLayout", "fontScale",
                                 "uiMode", "orientation", "density",
                                 "screenSize", "smallestScreenSize"]
          android:directBootAware=["true" | "false"]
          android:documentLaunchMode=["intoExisting" | "always" |
                                  "none" | "never"]
          android:enabled=["true" | "false"]
          android:excludeFromRecents=["true" | "false"]
          android:exported=["true" | "false"]
          android:finishOnTaskLaunch=["true" | "false"]
          android:hardwareAccelerated=["true" | "false"]
          android:icon="drawable resource"
          android:immersive=["true" | "false"]
          android:label="string resource"
          android:launchMode=["standard" | "singleTop" |
                              "singleTask" | "singleInstance"]
          android:lockTaskMode=["normal" | "never" |
                              "if_whitelisted" | "always"]
          android:maxRecents="integer"
          android:maxAspectRatio="float"
          android:multiprocess=["true" | "false"]
          android:name="string"
          android:noHistory=["true" | "false"]  
          android:parentActivityName="string" 
          android:persistableMode=["persistRootOnly" | 
                                   "persistAcrossReboots" | "persistNever"]
          android:permission="string"
          android:process="string"
          android:relinquishTaskIdentity=["true" | "false"]
          android:resizeableActivity=["true" | "false"]
          android:screenOrientation=["unspecified" | "behind" |
                                     "landscape" | "portrait" |
                                     "reverseLandscape" | "reversePortrait" |
                                     "sensorLandscape" | "sensorPortrait" |
                                     "userLandscape" | "userPortrait" |
                                     "sensor" | "fullSensor" | "nosensor" |
                                     "user" | "fullUser" | "locked"]
          android:showForAllUsers=["true" | "false"]
          android:stateNotNeeded=["true" | "false"]
          android:supportsPictureInPicture=["true" | "false"]
          android:taskAffinity="string"
          android:theme="resource or theme"
          android:uiOptions=["none" | "splitActionBarWhenNarrow"]
          android:windowSoftInputMode=["stateUnspecified",
                                       "stateUnchanged", "stateHidden",
                                       "stateAlwaysHidden", "stateVisible",
                                       "stateAlwaysVisible", "adjustUnspecified",
                                       "adjustResize", "adjustPan"] >   
    . . .
</activity>




contained in :	<application>

can contain :	<intent-filter>
		<meta-data>
		<layout>

description :
	
	Declares an activity that implements part of the application's visual user interface.


=> android:exported
this element sets whether the activity can be launched by components of the other applications -- "true: if it can be and "false" if not.
If "false" the activity can be launched only by components of the same applicaiton or applications with the same user ID.

if you are using intent  filter you should not set this element "flase" if you do so and an app tries to call the activtiy system throws an ActivityNotfoundException.
if you don' have the intent filters the default value for this element is false.


=> android:screenOrientation
The orientation of the activity's display on the device. The system ignores this attribute if the activity is running in multi-window mode.
The value can be any one of the following strings:

1) unspecified	the default value the system choose the orientation the policy it uses and there for choice made in specific contect may diffre from device to device.



=> android:shoeForAllUser
whether or not the activity is shown when the device's current user is diffrent  than the user when launched the activity.you can set this attribute to a resource or theme attribute that contains a boolean value.



Configure your Build :---------------------





<category>  :--------------------------------

<category android:name="string"/>

contined in: 
	<intent-filter>

description:
	Adds a category name to an intent filter

attribute:
	android:name

	The name of the category. Standard categories are defined in the  Intent class as CATEGORY_name constants
	For example the string value for CATEGORY_LAUNCHER is "android.intent.category.LAUNCHER".

In order ro receive implicit intents you must include the CATEGORY_DEFAULT category in the intent filter. The methods startactivity().

category -- Give additional information about the action to execute.
CATEGORY_LAUNCHER means it should appear in the launcher as a top-level application
CATEGORY_ALTERNATIVE means it should be included in a list of alternative actions the user can perform on a piece of data.
MAIN means that this activity in the entry point of the application i,e when you launched the application this activity is created.









10:52 AM 9/7/2019
	Button Advanced Operation :-----------------

Performing the Switch operation on button

package com.example.nestedbutton;

import androidx.appcompat.app.AppCompatActivity;
import android.widget.Toast;
import android.widget.Button;
import android.view.View;
import android.os.Bundle;

public class MainActivity extends AppCompatActivity {
    private Button b1,b2;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void clickme(View view)
    {
        switch (view.getId())
        {
            case R.id.button1:
                b1=(Button)findViewById(R.id.button1);
                String button1=b1.getText().toString();
                Toast.makeText(getApplicationContext(),button1,Toast.LENGTH_LONG).show();
                break;
            case R.id.button2:
                b2=(Button)findViewById(R.id.button2);
                String button2=b2.getText().toString();
                Toast.makeText(getApplicationContext(),button2,Toast.LENGTH_LONG).show();
                break;
        }
    }
}


2) Make the Button Stylish :-------

we can make button stylish using the 
android:background="@drawable/botton_corner.xml

that file should be present inside the button_corner( file name) under drawable folder.





3:03 PM 9/5/2019

Application Fundamentals :------------
Android apps can be written using Kotlin,Java and C++ languages . The Android SDK tools compiles your code along with any data and recources files into an APK, an Android package
which is an archive file with an .apk suffix.
One APK file contains all the content of an Android app and is the file that Android-powered device use to install the app.


The Android system implements the principle of least privilage .That is each app by default has access only to the components that it requires to do its work and no more. This creates a very secure environment only to the components that it requires to do
 its work and  no more. This creates a very secure environment in which an app can't access parts of the system for which it is not given permisson.




	Application Component :-----------------

App components are essentially building blocks of an Android app. Each component is an entry point through which the system or a user can enter your app. Some component depends on others.
 
there are four different types of app components :-
1) Activities
2) Services
3) Broadcast Receiver
4) Content Provides			(x)

Each type serves a distinct purpose and has a distinct lifecycle that defines how the component is created and destroyed

1) Activity
An Activity is the entry point for interacting with the user.
It represent a single screen with a user interface.
Example  an email app might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails.


2) Services
A services is a general-purpose entry point for keeping an app running background for all kinds of reasons.
 It is a component that runs in the background to perform long-running operations or to perform work for remote processes. A services does not provide a user interface.
Example a service might play music in the background while the user is in a different app, or it might fetch data over the network without blocking user interaction with an activity.


Bound services run because some other app (or the system) has said that it wants to make use of the service. This is basically the service providing an API to another process.

3) Broadcast Receiver
A broadcast receiver is a component that enables the system to deliver events to the app outside of a regular user flow, allowing the app to respond to system-wide broadcast 
announcements. Because broadcast receivers are another well-defined entry into the app, the system can deliver broadcasts even to apps that aren't currently running.


4) Content Providers
A content provider manages a shared set of app data that you can store in the file system, in a SQLite database, on the web, or on any other persistent storage location that your app can 
access. Through the content provider, other apps can query or modify the data if the content provider allows it. 
For example, the Android system provides a content provider that manages the user's contact information.



	Activating Components :----------------

Three of the four component types --activities , services, and broadcast receivers -- are activated by an asynchronous message called an Intent.
Intent bind individual component to each other at runtime. An intent is created with an Intent object, which defines a message to activate either a specific component (explicit intent ) or a 
specific type of component (impicit intent).

For activities and services an intent defines the action to be perform (for example to view  or send something) 










	Broadcast overview :-----------------------

Android apps can send or receive broadcast message from the Android system and other Android apps.
These broadcast are sent when an event of interest occurs. For example the Android system sends broadcast when various system events occurs such as when the system boots up or the 
device stats charging. App can also send custom broadcast, For example to notify other apps of something that they might be interested in(for example some new data has been downloaded).

Apps can register to receive specific broadcasts. When a broadcast is sent, the system automatically routes broadcasts to apps that have subscribed to receive that particular type of 
broadcast.



=> About system broadcasts

The system automatically sends broadcasts when various system events occur, such as when the system switches in and out of airplane mode. System broadcasts are sent to all apps that 
are subscribed to receive the event.

The broadcast message itself is wrapped in an Intent object whose action string identifies the event that occurred (for example android.intent.action.AIRPLANE_MODE). 
The intent may also include additional information bundled into its extra field. For example, the airplane mode intent includes a boolean extra that indicates whether or not Airplane Mode is on.


=> Changes to system broadcasts
As the Android platform evolves, it periodically changes how system broadcasts behave. Keep the following changes in mind if your app targets Android 7.0 (API level 24) or higher, or
 if it's installed on devices running Android 7.0 or higher.

Android 9
Beginning with Android 9 (API level 28), The NETWORK_STATE_CHANGED_ACTION broadcast doesn't receive information about the user's location or personally identifiable data.

In addition, if your app is installed on a device running Android 9 or higher, system broadcasts from Wi-Fi don't contain SSIDs, BSSIDs, connection information, or scan results. 
To get this information, call getConnectionInfo() instead.

Android 8.0
Beginning with Android 8.0 (API level 26), the system imposes additional restrictions on manifest-declared receivers.

If your app targets Android 8.0 or higher, you cannot use the manifest to declare a receiver for most implicit broadcasts (broadcasts that don't target your app specifically). 
You can still use a   {  context-registered receiver   }   when the user is actively using your app.


Android 7.0
Android 7.0 (API level 24) and higher don't send the following system broadcasts:

ACTION_NEW_PICTURE
ACTION_NEW_VIDEO
Also, apps targeting Android 7.0 and higher must register the CONNECTIVITY_ACTION broadcast using registerReceiver(BroadcastReceiver, IntentFilter).
Declaring a receiver in the manifest doesn't work.


=> Context-Register Receiver
To register a receiver with a context perform the following steps:

1) Create an instance of BroadcasarReceiver in onCreate() method

	BroadcastReceiver br=new MyBroadcastReceiver();

2) Create an IntentFilter and register the receiver by calling registerReceiver (BoradcastReceiver,IntentFilter):

	IntentFilter filter=new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
	filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
	registerReceiver(br,this);


	in Android Oreo and higher version we can register the receiver in MainActivity class in onResume or onCreate method but we will have to unregister the broadcastreceiver 

	=> 	@Override
    		protected void onResume()
    		{
    		        super.onResume();
    		        IntentFilter filter=new IntentFilter();
    		        //filter.addAction("android.net.conn.CONNECTIVITY_CHANGED");if we want to perform some action
    		        registerReceiver(myreceiver,filter);
    		}

3) To stop receiving broadcasts, call unregisterReceiver(android.content.BroadcastReceiver). Be sure to unregister the receiver when you no longer need it or the context is no longer 
valid.

@Override
    protected void onPause()//for unregistering the broadcast receiver
    {
        super.onPause();
        unregisterReceiver(myreceiver);
    }


4) Sending the Broadcast

    public void broadcastIntent(View view)
    {
        Intent intent=new Intent();
        intent.setAction("com.example.broadcastreceiver.CUSTOM_INTENT");//register that intent in the xml file
        intent.setComponent(new ComponentName(getPackageName(),"com.example.broadcastreceiver.MyReceiver"));
        //getApplicationContext().sendBroadcast(intent);
        sendBroadcast(intent);
    }




Be mindful of where you register and unregister the receiver, for example, if you register a receiver in onCreate(Bundle) using the activity's context, you should unregister it in 
onDestroy() to prevent leaking the receiver out of the activity context. If you register a receiver in onResume(), you should unregister it in onPause() to prevent registering it multiple
times (If you don't want to receive broadcasts when paused, and this can cut down on unnecessary system overhead). Do not unregister in onSaveInstanceState(Bundle), because this
isn't called if the user moves back in the history stack



Sending Broadcasts :-----------------------

Android provides three ways for app to send broadcast

1) The sendOrderedBroadcast(Intent,String) methods sends broadcast s to one receiver at a time. As each receiver executes it turn it can propagate a result to the receiver or it can 
completelt abort the broadcast so that it won't be passed to other receivers.The order receiver run in can be controlled with the android:parioority attribute of amtching intent-filter receiver with 
the same protity will be run in an arbitrary order.

2) The sendBroadcast(Intent) method sends broadcasts to all receivers in an undefined order. This is called a Normal Broadcast. This is more efficient, but means that receivers cannot 
read results from other receivers, propagate data received from the broadcast, or abort the broadcast.

3)The LocalBroadcastManager.sendBroadcast method sends broadcasts to receivers that are in the same app as the sender. If you don't need to send broadcasts across apps,
use local broadcasts. The implementation is much more efficient (no interprocess communication needed) and you don't need to worry about any security issues related to other apps
being able to receive or send your broadcasts.

	BroadCast Receiver ;---------------------------------------

In Android Broadcast Receiver is a component which  will allow android system or other system or other apps to delever events to the app like sending a low battery message or screen turned off
message to the app. The app can also broadcast to let other apps know that required data availabe in a device to use it.

Generally we use Intent to deliver broadcast events to other apps and Boradcast Recciver use status bar notification to let user know that broadcast events occurs.
In android Broadcast Receiver is implementted as a subclass of BroadcastReceiver and each braodcast is delivered as an Intent object.

we can register an app to receive only few broadcast message based on our requirements. When a new broadcasr received the system will check for specifieed have subscribed or not subscribed or not based on that it will routes the broadcast to the apps.

1)

One way is by registring a broadcast using android application manifest file (AndroidManifest.xml) we need to specify <receiver> element in apps manifest file line as shown below.

<receiver android:name=".SampleBroadcastReceiver">

    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED"/>
    </intent-filter>
</receiver>

2)
Suppose if we register for ACTION_BOOT_COMPLETED events whenever the boot process is completed the broadcast receiver's method onReceive() method will be invoked.





	Sending Broadcasts :-----------------------

In android, we can send a broadcasts in apps using three different ways, those are 

Method					Description

sendOrderedBroadcast(Intent, String)		This method is used to send broadcasts to one receiver at a time.
sendBroadcast(Intent)			This method is used to send broadcasts to all receivers in an undefined order.
LoadBroadcastManager.sendBroadcast		This method is used to send broadcasts to receivers that are in the same app as the sender.














Android Manifest file :---------------------



Before the Android system can start an app component , start system must know that the component exist by reading the app's manifest file AndroidManifest.xml.
Your app must declare all its component  in this file which must be at the root of the app project directory.

The Manifest does a number of thing in addition to declaring the app's components such as the following:-
=> Identifies any user permission the app requires such  as internet access or read-access to the user's contacts.
=> Declaring the minimum level API Level required by the app based on which APIs the app uses.
=> Declares hardware and software feature sued or required by the app such as a camera, bluetooth service or a multitouch screen.
=> Declares API libraries the app needs to be linked againest 

<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>

In the <application> element, the android:icon attribute points to resources for an icon that identifies the app.

In the <activity> element, the android:name attribute specifies the fully qualified class name of the Activity subclass and the android:label attribute specifies a string to use as the 
user-visible label for the activity.


You must declare all app components using the following elements:

<activity> elements for activities.
<service> elements for services.
<receiver> elements for broadcast receivers.
<provider> elements for content providers.
Activities, services, and content providers that you include in your source but do not declare in the manifest are not visible to the system and, consequently, can never run. 
However, broadcast receivers can be either declared in the manifest or created dynamically in code as BroadcastReceiver objects and registered with the system by calling 
registerReceiver().







Declaring component capabilities :----------------------------

As discussed above, in Activating components, you can use an Intent to start activities, services, and broadcast receivers. You can use an Intent by explicitly naming the target component
(using the component class name) in the intent. You can also use an implicit intent, which describes the type of action to perform and, optionally, the data upon which you’d like to perform 
the action. 

The system identifies the components that can respond to an intent by comparing the intent received to the intent filters provided in the manifest file of other apps on the device.









	App resources Overview :--------------------------------

Resources are the additional files and static content that your code uses such as bitmap, layout definitions, user interfaces string, animation instruction and more.
You should always externalize app resources such as image and string from your code so that you can maintain them independently. you should also provide alternative resources for specific 
device configurations by grouping them in specially-named resources directories. At runtime android uses the appropriate resource based on the cureent configuration.


	














	Services :-----------------------------------------------

A services is an application component that can perform long-running operations in the background, and it doesn't provides a user interface.
Another application component can start a service and it continues to run in the background even if the user switches to another application.

Additionally a component can bind to service to interact with in and even perform interprocess communication (IPC)

For example a service can handle network transaction, play music, perform file I/O or interact with a content provider all from the background.



	There are three different types of services:

1) Foreground

A foreground service performs some operations that is noticeable to the user.
For example an audio app would use a foreground service to play an audio track. Foreground service must display a Notification.
Foreground services continue running even when the user isn't interacting with the app.

2) Background 

A background service performs an oparation that isn't directly noticed by the user.
For example if an app used a service its storage that would usually be a background service.

Note: If your app targets API level 26 or higher, the system imposes restrictions on running background services when the app itself isn't in the foreground. In most cases like this, 
your app should use a scheduled job instead


3) Bound
A service is bound when an application compoennt binds to it by calling bindService().
A bound service offeres a client-server interface that allows components to interact with the service, send request, receive result and even do so across processes with interprocess communication (IPC).
A bound service runs only as long as another application component is bound to it. Multiple components can bind to the service at once but when all of them unbind, the service is destroyed.



Although this documentation generally discusses started and bound services separately, your service can work both ways—it can be started (to run indefinitely) and also allow binding. 
It's simply a matter of whether you implement a couple of callback methods: onStartCommand() to allow components to start it and onBind() to allow binding.


=> Choosing between a service and a thread :--

A service is simply a component that can run in the background even when the user is not interacting with your application so you should create a service only if that is what you need.

if you must perform work outside of your main thread but only while the user is interacting with your application youshould create  anew thread. 
For example if you want to play some music but only while your activity is running you might create a thread in onCreate(), start running it in onStart() and onStop() and stop it in on Stop().
Also consider using AsyncTask or Handlerthread instead of the traditional Thread class.





	The basic :--------------------

To create a service you must create a subclass of service or use one of its existing subclasses.
In your implemnetation you must override some callback methods that handle aspect of the service lifecycle and provide a mechanism that allows the component to bind to the service.

=> onStartCommand()

The system invokes this method by calling startService() when another component (such as an activity) requests that the service be started. When this method executes, the service
is started and can run in the background indefinitely. If you implement this, it is your responsibility to stop the service when its work is complete by calling stopSelf() or stopService(). 
If you only want to provide binding, you don't need to implement this method.

=> onBind()

The system invokes this method by calling bindService() when another component wants to bind with the service (such as to perform RPC). In your implementation of this method,
you must provide an interface that clients use to communicate with the service by returning an IBinder. You must always implement this method; however, if you don't want to allow 
binding, you should return null


=> onCreate()
The system invokes this method to perform one-time setup procedures when the service is initially created (before it calls either onStartCommand() or onBind()).
If the service is already running, this method is not called.

=> onDestroy()
The system invokes this method when the service is no longer used and is being destroyed. Your service should implement this to clean up any resources such as threads, registered 
listeners, or receivers. This is the last call that the service receives.

If a component starts the service by calling startService() (which results in a call to onStartCommand()), the service continues to run until it stops itself with stopSelf() or another 
component stops it by calling stopService()

If a component calls bindService() to create the service and onStartCommand() is not called, the service runs only as long as the component is bound to it. After the service is 
unbound from all of its clients, the system destroys it.



=> Declaring a service in the manifest
you must declare all service in your application's manifest file just as you do for activities and other components.
To declare your service add a <service> element as a child of the <application> element.

<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>



There are other attributes that you can include in the <service> element to define properties such as the permissions that are required to start the service and the process in which 
the service should run.

android:name attribute is the only required attribute --it specifies the class name of the service. After you publish your application leave this name unchanged to avoid the risk of breaking 
code due to dependence on explicit intents to start or bind the service.




Notice that the onStartCommand() methods must return an Integer. The integer is a value that describe how the system should continue the service in the event that the system kills it.The default
implementation for IntentService handles this for you but you are able to modify it. The return value from onStartCommand() must be one of the following constants:

1)START_NOT_STICKY
If the system kills the service after onStartCommand() return do not recreate the service unless there are pending intents to deliver.This is safest option to avoid running service when 
not necessary and when your application can simply restart any unfinished jobs.

2) START_STICKY
if the system kills the service after onStartCommand() returns recreate the service and call onStartCommand() but do not redeliver the last intent.In that case those intents are delivered.This 
is suitable for media players (or similar service) that are not executing commands but are running indefinitely and waiting for a job.


3) START_REDELIVER_INTENT
if the system kills the service after onStartCommand() return recreate the service and call onStartCommand() with the last intent that was deliverd to the service.
Any pending intents are delivered in turn. This is suitable for services that are actively performing a job that should be immediately resumed such as download a file.



Starting a Services :-----------------------------
you can start a service from an activity or other application component by passing an Intent to startService() or startForegroundService().
The Android system calls the service's onStartCommand() methods and pass it the Intent which specifies which service to start.


Note: If your app targets API level 26 or higher, the system imposes restrictions on using or creating background services unless the app itself is in the foreground. If an app needs to 
create a foreground service, the app should call startForegroundService(). That method creates a background service, but the method signals to the system that the service will promote 
itself to the foreground. Once the service has been created, the service must call its startForeground() method within five seconds.

For example an activity can start the example service in the previous section (helloService) using an Explicit intent with startService()

Intent intent=new Intent(this,HelloService.class);
startService(intent);

The startService() method returns immediately and the Android system calls the service's onStartCommand() method if the service isn't already running the system first calls onCreate()
and then it calls onStartCommand().

If the service doesn't also provide binding, the intent that is delivered with startService() is the only mode of communication between the application component and the service.
However, if you want the service to send a result back, the client that starts the service can create a PendingIntent for a broadcast (with getBroadcast()) and deliver it to the service in the Intent that starts the service. The service can then use the broadcast to deliver a result.

Multiple requests to start the service result in multiple corresponding calls to the service's onStartCommand(). However, only one request to stop the service 
(with stopSelf() or stopService()) is required to stop it






=> Sending notification to the user :---------------------------

When a service is running it can notify the user of events using ToastNotification or Status bar notificatios.

A Toast Notification is a message that appears on the surface of the surrent windows fo ronly a moment before disappearing.
A status bar notification provides an icon in the status bar with a message which the user can select in order to make an action (such as start an activity)

Usually a status bar Notification is best technique to use when background works such as a file download has completed, and the user cannow act on it.
When the user select the notification from the expanded view the notification can start an activity (such as to display to downloaded file)



=>Running a service in the Foreground :---------------------

A foreground service is a service that the user is actively aware of and  isn't a candidate fro the system to kill when low on memory.
Foreground service must provides a notification for the status bar which in placed under ongoing heading .
This meas that the notification cannot be dismissed unless the service is either stopped or removed from the foreground.


For Example,  a music player that plays music from a service should be set to run in the foreground, because the user is explicitly aware of its operation.
 The notification in the status bar might indicate the current song and allow the user to launch an activity to  interact with the music player. Similarly, an app to let users track their runs 
would need a foreground service to track the user's location.

To request that your service run in the foreground, call startForeground(). This method takes two parameters: an integer that uniquely identifies the notification and the 
Notification for the status bar. The notification must have a priority of PRIORITY_LOW or higher. 


Intent notificationIntent = new Intent(this,ExampleActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(this,0,notificationIntent,0);

Notification notification = new Notification.Builder (this,CHANNEL_DEFAULT_IMPORTANCE)
	..setContentTitle(getText(R.string.notification_title))
    	.setContentText(getText(R.string.notification_message))
    	.setSmallIcon(R.drawable.icon)
    	.setContentIntent(pendingIntent)
    	.setTicker(getText(R.string.ticker_text))
    	.build();

startForeground(ONGOING_NOTIFICATION_ID, notification);


To remove the service from the foreground, call stopForeground(). This method takes a boolean, which indicates whether to remove the status bar notification as well. 
This method does not stop the service. However, if you stop the service while it's still running in the foreground, the notification is also removed.




10:31 AM 9/3/2019


	Intent :------------

public class Intent extends Object implements Parcelable, Cloneable

Parcelable => Interface for classes whose instance can be written to and restored from a Parcel. Classes implementing the Parcelable interface must also have a non-null static field caled 
	       CREATOR of a type that implements the Parcelable.Creator interface
Parcel	 => Container for a message (data and object references) that can be sent through an IBinder.

Cloneable => A class implements the Cloneable interface to indicate to the Object.clone() method that it is legal for that method to make a field-for-field copy of instance of that class.
		creates and returns a copy of this object.


An Intent is an abstract description of an operation to be performed. It can be used with
Intents are asynchronus message which allow Android component to request functionality from other component of the Android System.

startActivity(Intent) 	=> to launched an Activity
broadcastIntent	=> to send it to any interested  BroadcastReceiver components
startService(Intent)	/ bindService(Intent, ServiceConnection, int)	=> to communicate with background.

Intent has been used to call another acitivity
Its most significant use  is in the launching of activites, where it can be throught of as the glue between activites.
It is basically a passive data structure holding an abstract description of an action to be performed.



Intent Structure :--------------
The primary pieces of information in an intent are :

1) Action	:- the general action to be performed such as  ACTION_VIEW,  ACTION_EDIT,  ACTION_MAIN

2) Data	:- the data to operate on such as a person records in the contact database, expressed as a Uri.

Some of the Example of action/data pair are: --------

1) ACTION_VIEW content://contacts/people1 => display information about the person whose identifier is 1
2) ACTION_DIAL tel:123	=> display the phone dialer with the given number filled in 


Inaddition to these primary attributes there are number of secondary attribute that you can also include with an intent:-

3) Category	:- gives additional information about the action to execute. For example CATEGORY_LAUNCHER means it should appear in the Launcher as a top-level application.

4) Type		:- specifies an explicity type (a MIME type) of the intent data

5) Component	:- specifies an explicit name of a component class to use for the intent >Normally this is determined by looking at the other information in the intent (action, data/type and categories)
		and matching that with a component that can handle

6) Extras		:- this is a Bundle of any additional information.this can be used to provide extended information to the component.
		For example if we have a action to send an e-mail message we could include extra pieces of data here to supply a subject body etc.


In Android the reuse of other application components is a concept knowns as task. An application can access other Android components to achieve a task.
For Example from a component of your application you can trigger another component in the Android system which manage photos, even it thif component is not part of your application. 
In this component you select a photo and return to your application to use the selected photo.


 => Here are some examples of other operations you can specify as intents using these additional parameters:

ACTION_MAIN with category CATEGORY_HOME -- Launch the home screen.

ACTION_GET_CONTENT with MIME type vnd.android.cursor.item/phone -- Display the list of people's phone numbers, allowing the user to browse through them and pick one and return it to the parent activity.





Intent  Resolution :---------------
There are two primary forms of intents you will use

1) Explicit Intent
2) Implicit Intent


Explicit Intent :-----------
In Android Explicit Intent explicitly specify the name of component to be invoked by an activity and we use explicit intents to start a component in out own app.
By using explicit intents we can send or share data / content from one activity to another activity based on your requirement
Explicit intent going to be connected internal world of application suppose if you wants to connect one activity to another activity we can do this quoteby explicit intent.
To create an Explicit Intent we need to define the component name for Intent object.

It have specifies a component (via setComponent(CompoenntName) or setClass(Context,Class)),which provides the exact class to be run.Often these will not include any other information
simply beign a way fro an application to launch various internal acitvities it has as the user interact with the application.


Example :------------------------------
package com.example.explicitintent;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;

public class MainActivity extends AppCompatActivity {
    protected EditText firstnumber,secondnumber;
    protected Button sum;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        firstnumber=(EditText)findViewById(R.id.editText);
        secondnumber=(EditText)findViewById(R.id.editText2);
        sum=(Button)findViewById(R.id.button2);

        sum.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                int number1=Integer.parseInt(firstnumber.getText().toString());
                int number2=Integer.parseInt(secondnumber.getText().toString());
                int sum=number1+number2;
                Intent intent=new Intent(getApplicationContext(),ResultActivity.class);      //the intent is sending to other activity that is ResultActivity.java
                intent.putExtra("SUM"," "+sum);
                /*
                putExtra() adds extended data to the intent which of
                two parameter( name of extra data ) second parameter is( data )itself


                it is get called by getExtra() by the name that was specified
                 */
                startActivity(intent);						/// this ise used for starting the activity
            }
        });
    }
}


Now we are gonna register that activity in the AndroidManifest.xml file in <activity> tag

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.explicitintent">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity android:name=".ResultActivity" ></activity>			//here we declare the other activity class to which we are gonna interact after perform some event.

    </application>

</manifest>


//Now we have the another class that is resultactivity.java that is gonna be called after expliclit intent called.
{
    private ActionBar actionBar;
    @Override
    protected void onCreate(Bundle saveInstanceState) {

        super.onCreate(saveInstanceState);
        setContentView(R.layout.result);
        actionBar=getSupportActionBar();
        actionBar.setTitle("Explicit Intent - Activity2");
        TextView result=(TextView)findViewById(R.id.result_view);
        Intent intent=getIntent();
        String addition=(String)intent.getSerializableExtra("SUM");
        /*
        getExtra() fetches data which was added using putExtra()
         */
        addition="Sum = "+addition;
        result.setText(addition);
    }
}


//it will have the separeate layoutxml file  to show the UI.


=> getExtras()

public Bundla getExtras()
Reterieve a map of extended data from the intent

Returns
Bundle 		=> the map of all extras previously added with putExtra() or null if none been added.




Implicit Intent :-----------
These intent do not name a target and the field of the component name is left blank. Implicit intents are often used to activate component in other application.
It is not specified a component instead they must include enough information for the system to determine which of the available component is best to run for that intent.

When using implicit intent given such an arbitaray intent we need to know what to do with it.This is handle by the process of intent resolution which maps an intent to an Activity
BroadCastreceiver or Service 

		The intent resolution mechanism basically revolve around matching an intnet against all of <intent-filter> descriptions in the installation package.

There are three pieces of information in the intent that are used for resolution: the action , type , and category

Intent-filter :------------------
Intent Filter is an expression in app's manifest file (ActivityManifest.xml) and it is used to specify the type of intent that the component would like to receive. In case if we create Intent filter 
for an activity there is a possibility for other apps to start our activity by sending a certain type of intent.
											otherwise the activity can be started only by an explicit intent.




There are three intent characteristics you can filter on the action , data and categories. 
For each of these characteriscs you can provides multiple possible matching values (via addAction(String),
 addDataType(String), addDataScheme(String), addDataSchemeSpecificpart(String ,int), addDataAuthority(String,String), addDataPath(String,int) and addCategory(String), respectively)


Filter Rule :-----------

A match is based on the following rule.Note that for an IntentFilter to match an Intent three condition must hold the action and category must match and the data (both data type and data 
scheme+authority+path if specified) must match

=> Action matches if any of the given values match the Intent action; if the filter specifies no actions, then it will only match Intents that do not contain an action.

=> Data Type matches if any of the given values match the Intent type. The Intent type is determined by calling Intent#resolveType. A wildcard can be used for the MIME sub-type, in both 
the Intent and IntentFilter, so that the type "audio/*" will match "audio/mpeg", "audio/aiff", "audio/*", etc. Note that MIME type matching here is case sensitive, unlike formal RFC MIME
types! You should thus always use lower case letters for your MIME types.

=> Data Scheme matches if any of the given values match the Intent data's scheme. The Intent scheme is determined by calling Intent#getData and Uri.getScheme() on that URI.
Note that scheme matching here is case sensitive, unlike formal RFC schemes! You should thus always use lower case letters for your schemes.

=> Data Scheme matches if any of the given values match the Intent data's scheme. The Intent scheme is determined by calling Intent#getData and Uri.getScheme() on that URI.
 Note that scheme matching here is case sensitive, unlike formal RFC schemes! You should thus always use lower case letters for your schemes.




Adds a data specificatio to an intent filter. The specification can be just a data type (the mime Type attribute),just a URI , or both a data types and a URI. A URI is specified by separated attributes
for each of its parts :-
These attribute that specifiy the URL fromat are optional but also mutually dependent
=> If a scheme is not specifies for the intent filter all the other URI attribute are ignored.
=> If a host is not specified for the filter the port attribute and all the path attributed are ignored.

setData() method specifies data ony as a URI
setType() specifies it only as a MIME type
setData and setType() specifies it as both a URI and a MIME type.
The URI is read by getData() 
The type is read by getType()




Generally the Intent Filter ( <intent-filter> ) whatever we define in manifest file can be nested in the corresponding app components and we can specify the type of intent to accept using these
three elements.

<Action>It define the name of an intent action to be accepted and it must be a literal string value of an action not the class contant.

<categories> it define the name of an intent category to be accepted and it must be the literal string value of an action not the class constant.

<data>
It defines the type of data to be accepted and by using one or more attributes we can specify various aspects of the data URI (scheme, host, port, path) and MIME type


Intent Filter in Manifest File 
Following is the code snippet of defining an activity with Intent Filter (<intent-filter>) in Android Manifest file (AndroidManifest.xml) like as shown below.

 

<activity android:name=".MainActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
        <data android:mimeType="text/plain"/>
    </intent-filter>
</activity>

We can define a filter with multiple instances of <action>, <category> or <data> elements and we need to make sure that component can handle all the combinations of filter elements.



























3:02 PM 9/10/2019

Fragments :---------------------------------------------

A Fragment is a piece of an activty which enable more modular activity design.It will not ne wrong if we say a fragment is a kind of sub activity.

Following are important points about fragment :--------------------------

A fragment has its own layout and its own behaviour with its own life cycle callbacks.

You can add or remove fragments in an activity while the activity is running.

You can combine multiple fragments in a single activity to build a multi-pane UI.

A fragment can be used in multiple activities.

Fragment life cycle is closely related to the life cycle of its host activity which means when the activity is paused, all the fragments available in the activity will also be stopped.

A fragment can implement a behaviour that has no user interface component.

Fragments were added to the Android API in Honeycomb version of Android which API version 11
When you add a fragment as apert of your activity layout it lives in a viewGroup inside the activity's view hierarrchy and the fragment defines its own view layout.
You can insert a fragment into your activty layout by declaring the fragment in the activity's layout file as a <fragment> element or from your application code by adding it to an 
existing ViewGroup.



Design Philosophy :-----------------------------
Android intorduced fragments in Android 3.0(API level 11) primarily to support more dynamic and flexible UI design on large screens such as tablets.Because a tablet's screen is much larger 
than of handset.
=> You create fragments by extending Fragment class and You can insert a fragment into your activity layout by declaring the fragment in the activity's layout file, as a <fragment> element






Creating a Fragment :--------------------
To Create a fragment you must create a subclass of fragment (or an existing subclass of it).
The fragment class has code that looks a lot like an Activity.
It contains callback methods similar to an sctivity such as onCreate(), onStart(), onPause() and onStop().


Fragment life-cycle :-----------------

1) onAttach()
 the fragment instance is associate with an activity instance. The fragment and the activity is not fully initialized.Typically you get in this method a reference to the activity
which uses the fragemnt for furthrt initialization work.

2) onCreate()
call this method when fragment is created

3) onCreateView()
call this method when fragment draw user interface for the first time. To draw a UI for your fragment you must return a view component from this method that is the root of fragment layout.

4) onActivityCreated()
The onActivityCreated() is called after onCreateView() method when the host activity is created.At this point view can be accessed with the findViewBy Id() method...

5) onStart()
this method is called once the fragemnt gets visible

6) onResume() fragment become active

7) onPause()
user in leaving the fragment

8) onStop() 
fragment is going to stop by calling onStop()

9) onDestroyView()
Fragment view will destroy after call this method

10) onDestroy
this is called to do final clean up.




life Cycle :-------------

			Activity				  			Fragment


1) onCreate()							2)onAttach()
the activty is able define its appearence by setContentView()			in this we get a reference of the activity in the fragment is placed

3)onAttachFragment							4) onCreate()
this method is called on the activity to notify the activity that			5) onCreateView()
								call this method when fragment draw user interface for the first time. To draw a UI for your fragment you 
								must return a view component from this method that is the root of fragment layout.

								6) onActivityCreated()
								The onActivityCreated() is called after onCreateView() method when the host activity is created.
								At this point view can be accessed with the findViewBy Id() method

7) onStart()							8)onStart()

9)onResume()							10) onResume()


Now Fragment is Destroyed :---------------------
			
								1) onPaused()
2)onPaused
								3)onSaveInstanceState()					
								give you bundle object to store some value
4)onSaveInstanceState()
								5)onStop()
6)onStop()
								7) onDestroyView()
								after this the fragment completely destroey

								8) onDetach()
								Fragment is not tied to the Activity and does not have View hierarchy

a fragment is attach recently





=> How to use Fragments?

This involves number of simple steps to create Fragments.

First of all decide how many fragments you want to use in an activity. For example let's we want to use two fragments to handle landscape and portrait modes of the device.

Next based on number of fragments, create classes which will extend the Fragment class. The Fragment class has above mentioned callback functions. You can override any of the functions based on your requirements.

Corresponding to each fragment, you will need to create layout files in XML file. These files will have layout for the defined fragments.

Finally modify activity file to define the actual logic of replacing fragments based on your requirement.


A fragment is usually used as part of an activity's user intterface an contributes its own layout to the acitivty.
To provide a layout for a fragment you must implement the onCreateView() callback methods which the Android system calls when it's time for the fragment to draw its layout. Your implementation
of this method must return a View that is the root of your fragment's layout.


public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }
}


The container parameter passed to onCreateView() is the parent ViewGroup in which your fragment layout in inserted.

The saveInstanceState parameter is a Bundle that provides data about the previous instance of the fragment if the fragment is being resumed.



inflate() method takes three arguments:

1) resource ID of the layout you want to inflate
2) ViewGroup to be the parent of the infalted layout.Passing the container is important in order for the system to apply layout parameter to root view of the infalted specified by the parent view 
in which it's going.
3) boolean indicating whether the inflate layout should be attached to the ViewGroup.


=> view.findViewById() is a call to a function by a reference of View class i.e view that is inflated using layout inflater

=> layout inflater
layout inflater is a class that help you to convert a View into java object and that is by creating is reference and call the function findViewbyId() using the reference view. this kind of inflation 
is mostly used in Fragment because unlike activities Fragments have no object they can't be instantiated.
Theri life cycle is totally depend upon the activities in which they are created.
These fragments have no java object that's why they don't take place in Manifest file,because these fragemnt are implemented in Activities

Adding a user interface :------------------------------
A fragment is usually used as part of an acitvity user interface and contributes its own layout to the activity.
To provide a layout from fragment you must implement the onCreateView() callback mwthod which must return a View that is the root of your fragmen' name.



Types of Fragments :----------------------

Basically fragments are divided as three stages as shown below.

1) Single frame fragments - Single frame fragments are using for hand hold devices like mobiles, here we can show only one fragment as a view.

2) List fragments - fragments having special list view is called as list fragment

3) Fragments transaction - Using with fragment transaction. we can move one fragment to another fragment




Adding a fragment to an Activity :------------------------


How to make Fragment :---------------------------

1) Extend Fragment class
2) Providing appearence in XML/Java
3) Override onCreateView to link the appearence
4) Use the Fragment in XML/Java



=> Usually a fragment contribute a portion of UI to the host activity which is embedded as a part of the activity's overall view hierarchy. 
There are two ways you can add a fragment to the activity layout:-------------------


1) Declare the fragment inside the activity's layout file

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
    <fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
</LinearLayout>

The android:name attribute in the <fragment> specifies the Fragment class to instantiate in the layout.


summary:--------------------------
we can add fragment by using the <fragment> tag that will be in the activity_main.xml file with a name of the  sub class that we declare in the MainActivity.java directory.






2) Programmatically add the fragment to an existing ViewGroup.


At any time while your activity is running you can add fragment to your activity layout. you simply need to specify a ViewGroup in which to place the fragment.

To make fragment transactions in your activity (such as add, remove, or replace a fragment), you must use APIs from FragmentTransaction. 
You can get an instance of FragmentTransaction from your FragmentActivity like this:

FragmentManager fragmentManager = getSupportFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

You can then add a fragment using the add() method,


ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();

The first argument passed to add() is the ViewGroup in which the fragment should be placed specified by resource ID, and  the second parameter fragment to add.


fragmentTransaction.add(R.id.framelayout,sample1)

Once you've made your changes with FragmentTransaction you must call commit() for the changes to take effect.



=> Managing Fragments

To manage the fragments in your activity, you need to use FragmentManager. To get it, call getSupportFragmentManager() from your activity.
Some things that you can do with FragmentManager include:

1) Get fragments that exist in the activity, with findFragmentById() (for fragments that provide a UI in the activity layout) or findFragmentByTag() (for fragments that do or don't provide a UI).
2) Pop fragments off the back stack, with popBackStack() (simulating a Back command by the user).
2) Register a listener for changes to the back stack, with addOnBackStackChangedListener().

For more information about these methods and others, refer to the FragmentManager class documentation.

As demonstrated in the previous section, you can also use FragmentManager to open a FragmentTransaction, which allows you to perform transactions,
such as add and remove fragments.


Before you call commit(), however, you might want to call addToBackStack(), in order to add the transaction to a back stack of fragment transactions. \
This back stack is managed by the activity and allows the user to return to the previous fragment state, by pressing the Back button


In this example, newFragment replaces whatever fragment (if any) is currently in the layout container identified by the R.id.fragment_container ID. By calling addToBackStack(), 
the replace transaction is saved to the back stack so the user can reverse the transaction and bring back the previous fragment by pressing the Back button.

FragmentActivity then automatically retrieve fragments from the back stack via onBackPressed()


=> addToBackStack()
public abstractFragmentTranscation addToBackStack(String name)

Add this transaction to the back stack. This means that the transaction will be rememberred offer it is committed and will reverse its operation whenlater popped off the stack

name => String : An optional name for this back stack state or null. This value may be null.

=> commit
public abstract int commit()
Schedules a commit of this transaction.
The commit does not happen immediately . it will be scheduled as work on the main thread to be done the next  time that thread ready.

=> detach 
public abstract FragmentTransaction detach (Fragment fragment)
Detach the given fragment from the  UI. This is the same state as when it is put on the back stack the fragment is removed from the UI however its sate is still being actively managed by the fragment manager. when going into this state its view
hierarchy is destroyed.

=> disallowAddTobackStack

public abstract FragmentTransaction disallowAddToBackStack()

Disallow calls to addToBackStack(java.lang.String). Any furture calls to addtoBackStack will throw IllegalStateException.
If addToBackStack has already been called this method will throw IllegalStateException.
reutrn FragmentTransaction


=> hide
public abstract fragmentTransaction hide (Fragment fragment)
Hides an existing  fragment. This is only relevant for fragment whode views has been added to a container as this will cause the view to be hidden.



=> isEmpty
true if this transaction contains no operations false otherwise.

=> remove
public abstract FragmentTransaction remove (Fragment fragment)

Remove an existing fragment. If it was added to a container, its view is also removed from that container.







=> Communication with the Activity :--------------------------------------------

Often you will want one Fragment to communicate with another for example to change the content based on a user event. All Fragment - to -  Fragment communication is done either through
a shared ViewModel or through the associated Activity. Two Fragment should never communicate directly.

The recommended way to communicate between fragments is to create a shared ViewModel object. Both fragments can access the ViewModel through their containing Activity. 
The Fragments can update data within the ViewModel and if the data is exposed using LiveData the new state will be pushed to the other fragment as long as it is observing the 
LiveData from the ViewModel.



Although a Fragment is implemented as an object that's idependent from a FragmentActivty and can be used inside multiple activities a given instance of a fragment is directly tied to the activity that hosts it.
 Specically the fragment can access the FragmentActivity instance with getActivity() and easily perform tasks such as find a view in the activity layout..


Define an Interface :--------------------
To allow a Fragment to communicate upto its Activity you can define an interface in the fragment class and implement it wihtin the Activity. The Fragment captures the interface implementation
during its onAttach() lifecycle method and can then call the interface method in order to communicate with the activity.


1)
buttonclick mclick;
public interface buttonclick
{
        void sendValue(String text);	
}



@Override
    public void onAttach(Activity activity)			//it is capturing the interface implementation during onAttach() lifecycle method
    {
        super.onAttach(activity);
        try
        {
            mclick=(buttonclick)activity;
        }
        catch (ClassCastException e)
        {
            throw new ClassCastException(activity.toString()+" must implement test click");
        }
    }



// Now the fragment can deliver message to the activity by calling the  sendValue() method (or other method in the interface using mclickinstance of interface
the following method in the fragment is called when the user clicks on a list item. The fragment uses the callback interface to deliver the event to the parent activity.

  public void someMethod(String text)		
    {
        mclick.sendValue(text);
    }




//In order to receive event callback from the fragment the activity that host it must implement the interface defined in the fragment class.
public class MainActivity extends AppCompatActivity implements fragmentone.buttonclick


//Deliver a Message to a fragment
The host activity can deliver messages to a fragment  by capturing the fragment instace with sendValue() then directly call the fragment's public method
 @Override
    public void sendValue(String text) {
        frag2.updateedittext(text);
    }














10:11 AM 9/4/2019

Notification :--------------------------------------------------

A notification is a message that android display outside your app's UI to provide the user with remainders communication from other people or other timely information from your app.


Appearance on a Device :----------------------

 Notification appear to user in different locations and formats such as an icon in the status bar a more detailed entry in the notification drawer as a badge on the app's icon and on paired wearable automatically.

1) Staus bar notification drawer
When you issue a notification, it first appears as an icon in the status bar.
Users can swipe down on the status bar to open the notification drawer, where they can view more details and take actions with the notification.


2) Heads-up notification
Beginning with Android 5.0, notifications can briefly appear in a floating window called a heads-up notification. This behavior is normally for important notifications that the user should 
know about immediately, and it appears only if the device is unlocked.

The heads-up notification appears the moment your app issues the notification and it disappears after a moment, but remains visible in the notification drawer as usual.

Example conditions that might trigger heads-up notifications include the following:

The user's activity is in fullscreen mode (the app uses fullScreenIntent).
The notification has high priority and uses ringtones or vibrations on devices running Android 7.1 (API level 25) and lower.
The notification channel has high importance on devices running Android 8.0 (API level 26) and higher.


4) Lock screen

Beginning with Android 5.0, notifications can appear on the lock screen.
You can programmatically set the ( level of detail visible ) in notifications posted by your app on a secure lock screen, or even whether the notification will show on the lock screen at all.
Users can use the system settings to choose the level of details visible in lock screen notifications, including the option to disable all lock screen notifications. Starting with Android 8.0, 
users can choose to disable or enable lock screen notifications for each notification channel.

5) App icon badge
In supported launchers on devices running Android 8.0 (API level 26) and higher, app icons indicate new notifications with a colored "badge" (also known as a "notification dot") 
on the corresponding app launcher icon.

Users can long-press on an app icon to see the notifications for that app. Users can then dismiss or act on notifications from that menu, similar to the notification drawer.


6) Wear OS devices
If the user has a paired Wear OS device, all your notifications appear there automatically, including expandable detail and action buttons.

You can also enhance the experience by customizing some appearances for the notification on wearables and provide different actions, including suggested replies and voice input 
replies. For more information, see how to add wearable-specific features to your notification.


Notification anatomy :-------------------

The design of a notification is determined by system templates—your app simply defines the contents for each portion of the template.


Notification actions
Although it's not required, every notification should open an appropriate app activity when tapped. In addition to this default notification action, you can add action buttons that complete
 an app-related task from the notification (often without opening an activity)

Expandable notification
By default, the notification's text content is truncated to fit on one line. If you want your notification to be longer, you can enable a larger text area that's expandable by applying an 
additional template


	Notification updates and groups :----------------------

To avoid bombarding your users with multiple or redundant notifications when you have additional updates, you should consider updating an existing notification rather than issuing a 
new one, or consider using the inbox-style notification to show conversation updates.

However, if it's necessary to deliver multiple notifications, you should consider grouping those separate notifications into a group (available on Android 7.0 and higher). 
A notification group allows you to collapse multiple notifications into just one post in the notification drawer, with a summary. The user can then expand the notification to 
reveal the details for each individual notification.



	Notification channels :------------------

Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel or it will not appear. By categorizing notifications into channels, users can disable specific notification 
channels for your app (instead of disabling all your notifications), and users can control the visual and auditory options for each channel—all from the Android system settings (figure 11).



	Notification importance :-------------------

Android uses the importance of a notification to determine how much the notification should interrupt the user (visually and audibly). The higher the importance of a notification, 
the more interruptive the notification will be.

On Android 8.0 (API level 26) and above, importance of a notification is determined by the importance of the channel the notification was posted to. Users can change the importance
 of a notification channel in the system settings (figure 12). On Android 7.1 (API level 25) and below, importance of each notification is determined by the notification's priority.



The possible importance levels are the following:

Urgent: Makes a sound and appears as a heads-up notification.
High: Makes a sound.
Medium: No sound.
Low: No sound and does not appear in the status bar.



	Do Not Disturb mode ;---------------

Starting in Android 5.0 (API level 21), users can enable Do Not Disturb mode, which silences sounds and vibration for all notifications. Notifications still appear in the system UI as
 normal, unless the user specifies otherwise.

There are three different levels available in Do Not Disturb mode:

Total silence: blocks all sounds and vibrations, including from alarms, music, videos, and games.
Alarms only: blocks all sounds and vibrations, except from alarms.
Priority only: users can configure which system-wide categories can interrupt them (such as only alarms, reminders, events, calls, or messages). For messages and calls, users can also 
choose to filter based on who the sender or caller is



Notifications for foreground services (Some Doubt)

A notification is required when your app is running a "foreground service"—a Service running in the background that's long living and noticeable to the user, such as a media player. 
This notification cannot be dismissed like other notifications. To remove the notification, the service must be either stopped or removed from the "foreground" state.


	Posting limits :---------------

Beginning with Android 8.1 (API level 27), apps cannot make a notification sound more than once per second. If your app posts multiple notifications in one second, they all appear as 
expected, but only the first notification per second makes a sound.



	Notification compatibility :--------------------------------

Since Android 1.0, the notification system UI and the notification-related APIs have continually evolved. To use the latest notification API features while still supporting older devices,
 use the support library notification API: NotificationCompat and its subclasses, as well as NotificationManagerCompat. This will allow you to avoid writing conditional code to check API 
levels because these APIs handle that for you.

NotificationCompat is updated as the platform evolves to include the latest methods. It is important to note that the availability of a method in NotificationCompat does not guarantee that 
the corresponding feature will be provided on older devices. In some cases calling a newly-introduced API results in a no-op on older devices. For example,
NotificationCompat.addAction() displays the action button on a device running Android 4.1 (API level 16) and higher only.




Create Basic Notification :------------------------

1) Set the notification content 

To get started you need to set the notification's content and channel using  ( NotificationCompat.Builder   Builder class for NotificationCompat objects. Allows easier control over all the 
flags, as well as help constructing the typical notification layouts.) object
The following example shows how to create a notification with the following:

A small icon, set by setSmallIcon(). This is the only user-visible content that's required.
A title, set by setContentTitle().
The body text, set by setContentText().
The notification priority, set by setPriority(). The priority determines how intrusive (Intruptive) the notification should be on Android 7.1 and lower. 
(For Android 8.0 and higher, you must instead set the channel importance—shown in the next section.)


NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)	//single interface for creating notification and let support library do all compatibility
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Much longer text that cannot fit one line...")
        .setStyle(new NotificationCompat.BigTextStyle()
                .bigText("Much longer text that cannot fit one line..."))
        .setPriority(NotificationCompat.PRIORITY_DEFAULT);


3) Show the notification

To make the notification appear, call NotificationManagerCompat.notify(), passing it a unique ID for the notification and the result of NotificationCompat.Builder.build(). For example:

NotificationManagerCompat  notificationManager = NotificationManagerCompat.from(this);

// notificationId is a unique int for each notification that you must define
notificationManager.notify(notificationId, builder.build());



//Updating Single Notification 
to update notification (that is already showing active) one just should just send new notification with the same.id Old notification will be replaced with new one.

2) Set the notification's tap action
Every notification should respond to a tap, usually to open an activity in your app that corresponds to the notification. To do so, you must specify a content intent defined with a 
PendingIntent object and pass it to setContentIntent().
for Handling clicking on notification one should set content intent.


//pendingintent is a special token it can be reterived from static methods such  as PendingIntent#getActivity, PendingIntent#getBroadcast #PedningInent#getService etc. to start service or send  broadcast.


Intent intent = new Intent(this, AlertDetails.class);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        // Set the intent that will fire when the user taps the notification
        .setContentIntent(pendingIntent)
        .setAutoCancel(true);


5) Add action buttons

A notification can offer up to three action buttons that allow the user to respond quickly, such as snooze a reminder or even reply to a text message. 
But these action buttons should not duplicate the action performed when the user taps the notification.

To add an action button, pass a PendingIntent to the addAction() method. 
This is just like setting up the notification's default tap action, except instead of launching an activity, 
you can do a variety of other things such as start a BroadcastReceiver that performs a job in the background so the action does not interrupt the app that's already open.



<Code>

Intent snoozeIntent = new Intent(this, MyBroadcastReceiver.class);
snoozeIntent.setAction(ACTION_SNOOZE);
snoozeIntent.putExtra(EXTRA_NOTIFICATION_ID, 0);
PendingIntent snoozePendingIntent =
        PendingIntent.getBroadcast(this, 0, snoozeIntent, 0);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        .setContentIntent(pendingIntent)
        .addAction(R.drawable.ic_snooze, getString(R.string.snooze),	 	// adding the PendingIntent instance in the addAction() method.
                snoozePendingIntent);



10:14 AM 9/5/2019

Since Android 0 release we can't show notification  by normal way
Notification channels enables us app developer to group our notification into group - channels
with the user having the ability to modify notification setting
Ex:- For each channel user can block all notification or allow notification to show.



=> Add a DIrect reply action :---------------------
The direct reply action introduced in ANdroid &.0 (API Level 24) allows uses to enter text directly into the notification which is delivered to your app without opening an activity.
You can use a direct reply action to let user reply to text message or update taks list from wihtin notificaiton.

Add the reply button

1) create an instance of RemoteInput.Builder that you add to your notification action. This class's constructor accepts a string that the system uses as the key for the text input

private static final String KEY_TEXT_REPLY="key_text_reply";
String replyLabel=getresource().getString(R.string.reply_label);
RemoteInput remoteInput=new RemoteInput.Builder(KEY_TEXT_REPLY)
.setLabel(replyLabel)
.build();

2) Create PendingIntent for the reply action

PendingIntent replyPendingIntent=PendingIntent.getBroadcast(getApplicationContext(), conversation.getConversationId(), getMessageReplyIntent(conversation.getConversationId()),PendingIntent.FLAG_UPDATE_CURRENT);


3) Attach the RemoteInput object to an action using addRemoteInput()
//create the reply action and add the remote input

NotificationCompat.Action action=new NotificationCompat.Action.Builder(R.drawable.ic__reply_icon,getString(R.string.label),replyPendingIntent)
.addRemoteInput(remoteInput)
.build();


4) Apply the action to a notification and issue the notificaiton

Notification newMessageNotification = new Notification.Builder(context,CHANNEL_ID)
.setSmallIcon(R.drawble.icon_message)
.setContentTitle(getString(R.string.title))
.setContentText(getString(R.string.content))
.addAction(action)
.build()

//Issue Notification
NotificationManagerCompat notificatioManager=NotificationManagerCompat.from(this);
notificationManager.notify(notificationId,newMessageNotification)



=> Reterieve user input from reply :-------------------

To receive user input from the notification's reply UI call RemoteInput.getResultsFromIntent() passing it the Intent received by your BroadcastReceiver

private ChaSequence getMessageText(Intent intent)
{
	Bundle remoteInput=RemoteInput.getResultsFromIntent(intent);
	if(remoteInput!=null)
	{
		return remoteInput.getCharSequence(KEY_TEXT_REPLY);
	}
	return NULL;
}



After you’ve processed the text, you must update the notification by calling NotificationManagerCompat.notify() with the same ID and tag (if used). This is necessary to hide direct reply 
UI and confirm to the user that their reply was received and processed correctly.

// Build a new notification, which informs the user that the system
// handled their interaction with the previous notification.
Notification repliedNotification = new Notification.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.ic_message)
        .setContentText(getString(R.string.replied))
        .build();	//here we use notification builder to set various notification properties like its small and large icons title priority etc.

// Issue the new notification.
NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
notificationManager.notify(notificationId, repliedNotification);





=> Set a system-wide category :--------------------

Android uses a some pre-defined system-wide categories to determine whether to distrub the user with a given notification when the user has enable Do Not Disturb mode.

if your notification falls into one of the pre-defined notification categories deined in NotificationCompat  such as  CATEGORY_ALARM, CATEGORY_REMINDER, CATEROY_EVENT or CATEGORY_CALL
you should declared it as such by passing the appropriate category to setCategory().

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)		// to set the priority
        .setCategory(NotificationCompat.CATEGORY_MESSAGE);  // use to set  when to interact with the user category


=> Show an Urgent Message :----------

Your app might need to display an urgent time-sensitive message such as an incoming phone call or a ringing alarm. In these situation you can associate a full-screen intent with your notification
When the notification is invoked users see one of the following depending on the device's lock status.

If the user's device is locked, a full-screen activity appears, covering the lockscreen.
If the user's device is unlocked, the notification appears in an expanded form that includes options for handling or dismissing the notification.

Intent fullScreenIntent = new Intent(this, ImportantActivity.class);
PendingIntent fullScreenPendingIntent = PendingIntent.getActivity(this, 0,
        fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        .setFullScreenIntent(fullScreenPendingIntent, true);



=> Set lock screen visibility

To control the level of detail visible in the notification from the lock screen, call setVisibility() and specify one of the following values:

VISIBILITY_PUBLIC shows the notification's full content.
VISIBILITY_SECRET doesn't show any part of this notification on the lock screen.
VISIBILITY_PRIVATE shows basic information, such as the notification's icon and the content title, but hides the notification's full content.

When VISIBILITY_PRIVATE is set, you can also provide an alternate version of the notification content which hides certain details. 
For example, an SMS app might display a notification that shows You have 3 new text messages, but hides the message contents and senders. 
To provide this alternative notification, first create the alternative notification with NotificationCompat.Builder as usual. 
Then attach the alternative notification to the normal notification with setPublicVersion().


=> Create a Expandable Notification :------------------

To start, build a notification with all the basic content as described in Create a Notification. Then, call setStyle() with a style object and supply information corresponding to each template

1) Add a Large Image
Notification notification=new NotificationCompat.Builder(context,CHANNEL_ID);  //because in notification class all the setStyle() method are define
.setSmallIcon(R.drawable.new_post)
.setContentTitle(imageTitle)
.setContextText(imageDescription)
.setStyle(new NotificationCompat.BigPictureStyle().bigPicture(myBitmap))
.build()


to make the image appear as a thumbnail only while the notification is collapse call setLargeIcon() and pass it the image, but also call BigPictureStyle.bigLargeIcon() and pass it 
null so the large icon goes away when the notification is expanded:

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_post)
        .setContentTitle(imageTitle)
        .setContentText(imageDescription)
        .setLargeIcon(myBitmap)
        .setStyle(new NotificationCompat.BigPictureStyle()
                .bigPicture(myBitmap)
                .bigLargeIcon(null))
        .build();



=> Add  a large block of text :----------

Apply NotificationCompat.BigTextStyle to display text in the expanded content area of the notification.

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_mail)
        .setContentTitle(emailObject.getSenderName())
        .setContentText(emailObject.getSubject())
        .setLargeIcon(emailObject.getSenderAvatar())
        .setStyle(new NotificationCompat.BigTextStyle()			// BigTextStyle to display text in the expanded content area of notification
                .bigText(emailObject.getSubjectAndSnippet()))
        .build();





=> Create an Inbox-style Notification :------------------

Apply NotificationCompat.InboxStyle to notification if you want to add multiple short summary line such as snippets from incoming emails.This allows you to add multiple pieces of content text
 that are truncated to one line instead of one continues line of text provided by NotificationCompat.BigTextStyle.

to add a new line call addLine() up to 6 times if you add more than 6 lines only the first 6 are visible.

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_mail)
        .setContentTitle("5 New mails from " + sender.toString())
        .setContentText(subject)
        .setLargeIcon(aBitmap)
        .setStyle(new NotificationCompat.InboxStyle()
                .addLine(messageSnippet1)
                .addLine(messageSnippet2))
        .build();




=> Show a conversation in a notification :-
Apply NotificationCompat.MessagingStyle to display sequential messages between any number of people. This is ideal for messaging apps because it provides a consistent layout for 
each message by handling the sender name and message text separately, and each message can be multiple lines long.

NotificationCompat.MessagingStyle.Message message1 =
        new NotificationCompat.MessagingStyle.Message(messages[0].getText(),
                                                      messages[0].getTime(),
                                                      messages[0].getSender());
NotificationCompat.MessagingStyle.Message message2 =
        new NotificationCompat.MessagingStyle.Message(messages[1].getText(),
                                                      messages[1].getTime(),
                                                      messages[1].getSender());

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_message)
        .setStyle(new NotificationCompat.MessagingStyle(resources.getString(R.string.reply_name))
                .addMessage(message1)
                .addMessage(message2))
        .build();
















	Drawable resource :---------------


====>
Project now created launcher icons in the mipmap resources filders instead of the drawable folders
Android introduced mipmap drawable for providing more flexibility to design the launcher icons. mipmap first introuduced in Android jelly Bean 4.3 . If you are building versions of your app for 
different densities you should know about the mipmap resource directory. This is exactly like normal drawable folder resources except it does not participate in density striping while 
optimisation when creating different target apks.

Why should we use mipmaps for app launcher icons?

Devices have different resolutions so the launcher app show the icons on different resolutions. Resource optimisation techniques sometimes removes resources for unused screen 
densities and when the launcher app has to upscale a lower-resolution icon for display it might look blurred. To avoid this issues, applications should use the mipmap drawable folders 
for app launcher icons. The Android system never strips this resource, and ensures that launcher apps can pick icons with the best resolution for display.

<===

A drawablw resource is a general concept for a graphics that can be drawn to the screen and which you can reterieve with APIs such as getDrawable(int) or apply to another XML resource 
attributes such as android:drawable and android:icon

Different types of Drawable :-

1) Bitmap		:- a bitmap graphics file (.png, .jgp, or .gif) create a BitmapDrawable
2) Nine-patch File	:- A PNG file with stretchable region to allow image resizing on content
3) Layer List	:- A drawable that manage an array of other Drawables .these are drawn in array order so the element with the largest index is be drawn on top.
4) State List	:- an XML file that reference different bitmap graphics for different states (for example to use a different image when a button is pressed)
5) Level List	:- an XML file that defines a drawable that manges a number of alternative Drawable each assign a maximum numerical value.
6) Transition Drawable :-  an XML file that define a drawable that can cross fade between two drawable resource.
7) Inset Drawable	:- an XML file that define drawable that insets another drawable by a specific distance.
8) clip drawable	:- an XML file that define a drawable that clip another drawabable
9) Scale Drawable	:- an xml file that define a drawable that change the size of another drawable
10) Shape Drawable		:- an XML file that defines a geometric shape including colors and gradient creates a GradientDrawable.




=> Bitmap file :------------------------------------------

A bitmap file is a .png, .jpg, or .gif file. Android creates a Drawable resource for any of these files when you save them in the res/drawable/ directory.


file location :
res/drawable/filename.png (.png, .jpg or .gif) the filename is used as the resource ID.

resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename


Example :-
<ImageView
    android:layout_height="wrap_content"
    android:layout_width="wrap_content"
    android:src="@drawable/myimage" />



XML bitmap :-----------
An XML bitmap is a resource defined in XML that points to a bitmap file. The effect is an alias fora raw bitmap file. the XML can specify additional properties for the bitmap such as 
dithering and tiling.

file location :
res/drawable/filename.xml 
the filename is used as the resiurce ID.


Shape Drawable :-----------------------------------
This is a generic defined in XML

file location:
		res/drawable/filename.xml
		The filename is used as the resource ID.

Compiled resource datatypes:----------------
Resouce pointer to a BitmapDrawable


syntax: --------------
<?xml version="1.0" encoding="utf-8"?>
<bitmap
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:src="@[package:]drawable/drawable_resource"
    android:antialias=["true" | "false"]
    android:dither=["true" | "false"]
    android:filter=["true" | "false"]
    android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" |
                      "fill_vertical" | "center_horizontal" | "fill_horizontal" |
                      "center" | "fill" | "clip_vertical" | "clip_horizontal"]
    android:mipMap=["true" | "false"]
    android:tileMode=["disabled" | "clamp" | "repeat" | "mirror"] />


android:filter
Boolean Enables or disables bitmap filtering. Filtering is used when the bitmap is shrunk or stretched to smooth its apperance.



android:gravity
Keyword Defines the gravity for the bitmap. The gravity indicates where to posotions the drawable in its container if the bitmap is smaller than the container.




Nine-Patch :----------------------------

A NinePatch is a PNG image in which you can define stretchable regions that Android scales when content within the View exceeds the normal image bounds. You typically assign this type 
of image as the background of a View that has at least one dimension set to "wrap_content", and when the View grows to accommodate the content, the Nine-Patch image is also scaled to 
match the size of the View. 


Nine-patch file

file location:
res/drawable/filename.9.png
thenfilename is used as the resource ID

compiled resource datatyped;
resource pointer to an NInepatchDrawable

reference resource
in java R.drawable.filename
in XML package]drawable/filename


<Button
    android:layout_height="wrap_content"
    android:layout_width="wrap_content"
    android:background="@drawable/myninepatch" />


XML Nine-Patch
An XML Nine-Patch is a resource defined in XML that points to a Nine-Patch file. The XML can specify dithering for the image.

file location:
res/drawable/filename.xml
The filename is used as the resource ID.

compiled resource datatype:
Resource pointer to a NinePatchDrawable.

resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename


<?xml version="1.0" encoding="utf-8"?>
<nine-patch
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:src="@[package:]drawable/drawable_resource"
    android:dither=["true" | "false"] />

<nine-patch>
Defines the Nine-Patch source and its properties.
attributes:

xmlns:android
String. Required. Defines the XML namespace, which must be "http://schemas.android.com/apk/res/android".
android:src
Drawable resource. Required. Reference to a Nine-Patch file.

android:dither
Boolean. Enables or disables dithering of the bitmap if the bitmap does not have the same pixel configuration as the screen (for instance: a ARGB 8888 bitmap with an RGB 565 screen).


Layer List :------------------
A LayerDrawable is drawable object that manages an array of other drawables. 
Each drawable in the list is drawn in the order of the list -the last drawable in hte list is drawn on top.

Each drawable is represented by an <item> element inside a single <layer-list> element.


file location:
res/drawable/filename.xml
The filename is used as the resource ID.
compiled resource datatype:
Resource pointer to a LayerDrawable.
resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename



<?xml version="1.0" encoding="utf-8"?>
<layer-list
    xmlns:android="http://schemas.android.com/apk/res/android" >
    <item
        android:drawable="@[package:]drawable/drawable_resource"
        android:id="@[+][package:]id/resource_name"
        android:top="dimension"
        android:right="dimension"
        android:bottom="dimension"
        android:left="dimension" />
</layer-list>


elements:
<layer-list>
Required. This must be the root element. Contains one or more <item> elements.
attributes:

xmlns:android
String. Required. Defines the XML namespace, which must be "http://schemas.android.com/apk/res/android".
<item>
Defines a drawable to place in the layer drawable, in a position defined by its attributes. Must be a child of a <layer-list> element. Accepts child <bitmap> elements.
attributes:

android:drawable
Drawable resource. Required. Reference to a drawable resource.
android:id
Resource ID. A unique resource ID for this drawable. To create a new resource ID for this item, use the form: "@+id/name". The plus symbol indicates that this should be created as a new ID. You can use this identifier to retrieve and modify the drawable with View.findViewById() or Activity.findViewById().
android:top
Integer. The top offset in pixels.
android:right
Integer. The right offset in pixels.
android:bottom
Integer. The bottom offset in pixels.
android:left
Integer. The left offset in pixels.

All drawable items are scaled to fit the size of the containing View by default. Thus plcing your image ina layer list at different position might increase the size of the 
View and some images scale as appropriate. To avoid scaling items in the list use a <bitmap> element inside the <item> element to specify the drawable and define the gravity to 
something that does not scale such as center.



<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
      <bitmap android:src="@drawable/android_red"
        android:gravity="center" />
    </item>
    <item android:top="10dp" android:left="10dp">
      <bitmap android:src="@drawable/android_green"
        android:gravity="center" />
    </item>
    <item android:top="20dp" android:left="20dp">
      <bitmap android:src="@drawable/android_blue"
        android:gravity="center" />
    </item>
</layer-list>

Notice that this example uses a nested <bitmap> element to define the drawable resource for each item with a "center" gravity. This ensures that none of the images are scaled to
 fit the size of the container, due to resizing caused by the offset images.


<ImageView
    android:layout_height="wrap_content"
    android:layout_width="wrap_content"
    android:src="@drawable/layers" />



State list :-----------------------------------
A StateListDrawable is a drawable object defined in XML that uses a several different images to represent the same graphic, depending on the state of the object. 
For example, a Button widget can exist in one of several different states (pressed, focused, or neither) and, using a state list drawable, you can provide a different background image 
for each state


You can describe the state list in an XML file. Each graphics is represented by an <item> element inside a single <selector> element .
Each <item> uses various attributes to describe the state in which it should be used as the graphic for the drawable.


During each state change, the state list is traversed top to bottom and the first item that matches the current state is used—the selection is not based on the "best match," but simply the
first item that meets the minimum criteria of the state.


file location:
res/drawable/filename.xml
The filename is used as the resource ID.

compiled resource datatype:
Resource pointer to a StateListDrawable.

resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename

syntex:-----

<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android"
    android:constantSize=["true" | "false"]
    android:dither=["true" | "false"]
    android:variablePadding=["true" | "false"] >
    <item
        android:drawable="@[package:]drawable/drawable_resource"
        android:state_pressed=["true" | "false"]
        android:state_focused=["true" | "false"]
        android:state_hovered=["true" | "false"]
        android:state_selected=["true" | "false"]
        android:state_checkable=["true" | "false"]
        android:state_checked=["true" | "false"]
        android:state_enabled=["true" | "false"]
        android:state_activated=["true" | "false"]
        android:state_window_focused=["true" | "false"] />
</selector>


elements:
<selector>
Required. This must be the root element. Contains one or more <item> elements.
attributes:

xmlns:android
String. Required. Defines the XML namespace, which must be "http://schemas.android.com/apk/res/android".
android:constantSize
Boolean. "true" if the drawable's reported internal size remains constant as the state changes (the size is the maximum of all of the states); "false" if the size varies based on the current state. Default is false.
android:dither
Boolean. "true" to enable dithering of the bitmap if the bitmap does not have the same pixel configuration as the screen (for instance, an ARGB 8888 bitmap with an RGB 565 screen); "false" to disable dithering. Default is true.
android:variablePadding
Boolean. "true" if the drawable's padding should change based on the current state that is selected; "false" if the padding should stay the same (based on the maximum padding of all the states). Enabling this feature requires that you deal with performing layout when the state changes, which is often not supported. Default is false.
<item>
Defines a drawable to use during certain states, as described by its attributes. Must be a child of a <selector> element.
attributes:

android:drawable
Drawable resource. Required. Reference to a drawable resource.
android:state_pressed
Boolean. "true" if this item should be used when the object is pressed (such as when a button is touched/clicked); "false" if this item should be used in the default, non-pressed state.
android:state_focused
Boolean. "true" if this item should be used when the object has input focus (such as when the user selects a text input); "false" if this item should be used in the default, non-focused state.
android:state_hovered
Boolean. "true" if this item should be used when the object is being hovered by a cursor; "false" if this item should be used in the default, non-hovered state. Often, this drawable may be the same drawable used for the "focused" state.
Introduced in API level 14.

android:state_selected
Boolean. "true" if this item should be used when the object is the current user selection when navigating with a directional control (such as when navigating through a list with a d-pad); "false" if this item should be used when the object is not selected.
The selected state is used when focus (android:state_focused) is not sufficient (such as when list view has focus and an item within it is selected with a d-pad).

android:state_checkable
Boolean. "true" if this item should be used when the object is checkable; "false" if this item should be used when the object is not checkable. (Only useful if the object can transition between a checkable and non-checkable widget.)
android:state_checked
Boolean. "true" if this item should be used when the object is checked; "false" if it should be used when the object is un-checked.
android:state_enabled
Boolean. "true" if this item should be used when the object is enabled (capable of receiving touch/click events); "false" if it should be used when the object is disabled.
android:state_activated
Boolean. "true" if this item should be used when the object is activated as the persistent selection (such as to "highlight" the previously selected list item in a persistent navigation view); "false" if it should be used when the object is not activated.
Introduced in API level 11.

android:state_window_focused
Boolean. "true" if this item should be used when the application window has focus (the application is in the foreground), "false" if this item should be used when the application window does not have focus (for example, if the notification shade is pulled down or a dialog appears).



element :----
button.xml

<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true"
          android:drawable="@drawable/button_pressed" /> <!-- pressed -->
    <item android:state_focused="true"
          android:drawable="@drawable/button_focused" /> <!-- focused -->
    <item android:state_hovered="true"
          android:drawable="@drawable/button_focused" /> <!-- hovered -->
    <item android:drawable="@drawable/button_normal" /> <!-- default -->
</selector>



<Button
    android:layout_height="wrap_content"
    android:layout_width="wrap_content"
    android:background="@drawable/button" />





Level list: --------------------------
A Drawable that manages a number of alternate Drawables, each assigned a maximum numerical value. Setting the level value of the drawable with setLevel() loads the drawable 
resource in the level list that has a android:maxLevel value greater than or equal to the value passed to the method


file location:
res/drawable/filename.xml
The filename is used as the resource ID.
compiled resource datatype:
Resource pointer to a LevelListDrawable.
resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename


syntax;-
<?xml version="1.0" encoding="utf-8"?>
<level-list
    xmlns:android="http://schemas.android.com/apk/res/android" >
    <item
        android:drawable="@drawable/drawable_resource"
        android:maxLevel="integer"
        android:minLevel="integer" />
</level-list>



elements:
<level-list>
This must be the root element. Contains one or more <item> elements.
attributes:

xmlns:android
String. Required. Defines the XML namespace, which must be "http://schemas.android.com/apk/res/android".
<item>
Defines a drawable to use at a certain level.
attributes:

android:drawable
Drawable resource. Required. Reference to a drawable resource to be inset.
android:maxLevel
Integer. The maximum level allowed for this item.
android:minLevel
Integer. The minimum level allowed for this item.



example:
<?xml version="1.0" encoding="utf-8"?>
<level-list xmlns:android="http://schemas.android.com/apk/res/android" >
    <item
        android:drawable="@drawable/status_off"
        android:maxLevel="0" />
    <item
        android:drawable="@drawable/status_on"
        android:maxLevel="1" />
</level-list>

Once this is applied to a View, the level can be changed with setLevel() or setImageLevel().





Transition Drawable :-----------------------------------

A TransitionDrawable is a drawable object that can cross-fade between the two resources.
Each drawable is represented by an <item> element inside a single <transition> element.

No more than two items are supported. To transition forword call startTransition() 		To transition backword call reverseTransition()


file location:
res/drawable/filename.xml
The filename is used as the resource ID.
compiled resource datatype:
Resource pointer to a TransitionDrawable.
resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename



syntex :-------
<?xml version="1.0" encoding="utf-8"?>
<transition
xmlns:android="http://schemas.android.com/apk/res/android" >
    <item
        android:drawable="@[package:]drawable/drawable_resource"
        android:id="@[+][package:]id/resource_name"
        android:top="dimension"
        android:right="dimension"
        android:bottom="dimension"
        android:left="dimension" />
</transition>


elements:
<transition>
Required. This must be the root element. Contains one or more <item> elements.
attributes:

xmlns:android
String. Required. Defines the XML namespace, which must be "http://schemas.android.com/apk/res/android".
<item>
Defines a drawable to use as part of the drawable transition. Must be a child of a <transition> element. Accepts child <bitmap> elements.
attributes:

android:drawable
Drawable resource. Required. Reference to a drawable resource.
android:id
Resource ID. A unique resource ID for this drawable. To create a new resource ID for this item, use the form: "@+id/name". The plus symbol indicates that this should be created as a new ID. You can use this identifier to retrieve and modify the drawable with View.findViewById() or Activity.findViewById().
android:top
Integer. The top offset in pixels.
android:right
Integer. The right offset in pixels.
android:bottom
Integer. The bottom offset in pixels.
android:left
Integer. The left offset in pixels.




XML file saved at res/drawable/transition.xml

<?xml version="1.0" encoding="utf-8"?>
<transition xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@drawable/on" />
    <item android:drawable="@drawable/off" />
</transition>


=> this layout XML applies the drawable to a view

<ImageButton
    android:id="@+id/button"
    android:layout_height="wrap_content"
    android:layout_width="wrap_content"
    android:src="@drawable/transition" />


=> and the following code performs 500ms transition from the first itsm to the second.

ImageButton button = (ImageButton) findViewById(R.id.button);
Drawable drawable = button.getDrawable();
if (drawable instanceof TransitionDrawable) {
    ((TransitionDrawable) drawable).startTransition(500);
}





=> Inset drawable :--------------------------------------------

A drawable defined in XML that insets another drawable by a specified distance. This is useful when a View needs a background that is smaller than the View's actual bounds.

file location:
res/drawable/filename.xml
The filename is used as the resource ID.
compiled resource datatype:
Resource pointer to a InsetDrawable.
resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename


<?xml version="1.0" encoding="utf-8"?>
<inset
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/drawable_resource"
    android:insetTop="dimension"
    android:insetRight="dimension"
    android:insetBottom="dimension"
    android:insetLeft="dimension" />



elements:
<inset>
Defines the inset drawable. This must be the root element.
attributes:

xmlns:android
String. Required. Defines the XML namespace, which must be "http://schemas.android.com/apk/res/android".
android:drawable
Drawable resource. Required. Reference to a drawable resource to be inset.
android:insetTop
Dimension. The top inset, as a dimension value or dimension resource
android:insetRight
Dimension. The right inset, as a dimension value or dimension resource
android:insetBottom
Dimension. The bottom inset, as a dimension value or dimension resource
android:insetLeft
Dimension. The left inset, as a dimension value or dimension resource



example:-
<?xml version="1.0" encoding="utf-8"?>
<inset xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/background"
    android:insetTop="10dp"
    android:insetLeft="10dp" />




Clip drawable :--------------------------
A drawable defined in XML that clips another drawable based on this Drawable's current level. You can control how much the child drawable gets clipped in width and height based on the 
level, as well as a gravity to control where it is placed in its overall container. Most often used to implement things like progress bars


file location:
	res/drawable/filename.xml
	The filename is used as the resource ID.

compiled resource datatype:
	Resource pointer to a ClipDrawable.

resource reference:
	In Java: R.drawable.filename
	In XML: @[package:]drawable/filename


syntax :-
<?xml version="1.0" encoding="utf-8"?>
<clip
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/drawable_resource"
    android:clipOrientation=["horizontal" | "vertical"]
    android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" |
                     "fill_vertical" | "center_horizontal" | "fill_horizontal" |
                     "center" | "fill" | "clip_vertical" | "clip_horizontal"] />





elements:

<clip>
Defines the clip drawable. This must be the root element.
attributes:

xmlns:android
String. Required. Defines the XML namespace, which must be "http://schemas.android.com/apk/res/android".
android:drawable
Drawable resource. Required. Reference to a drawable resource to be clipped.
android:clipOrientation
Keyword. The orientation for the clip.
Must be one of the following constant values:

Value	Description
horizontal	Clip the drawable horizontally.
vertical	Clip the drawable vertically.
android:gravity
Keyword. Specifies where to clip within the drawable.
Must be one or more (separated by '|') of the following constant values:
		



=> Scale drawable
A drawable defined in XML that changes the size of another drawable based on its current level.

file location:
res/drawable/filename.xml
The filename is used as the resource ID.
compiled resource datatype:
Resource pointer to a ScaleDrawable.
resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename






Supprt Different Pixel Densities :-------------------------------------

Not only do android come in different screen sizes (handsets, tablet, TVs and so on ) but their screens also have different pixels sizes. 
That is, while one device has 160 pixels per square inch, another device fits 480 pixels in the same space. If you don't consider these variations in pixel density, the system might scale 
your images (resulting in blurry images) or the images might appear at the completely wrong size.



Use density-independent pixels ;----------------------------------------------

The first pitfall you must avoid is using pixels to define distances or size. Defining dimensions with pixels is a problem because different screen have different pixels densities so the same
number of pixels may correspond to different physical sizes on different devices.

One dp is a virtual pixel unit that's roughly equal to one pixel on a medium-density screen (160dpi; the "baseline" density). Android translates this value to the appropriate number of real 
pixels for each other density.

When defining text sizes, however, you should instead use scalable pixels (sp) as your units (but never use sp for layout sizes). The sp unit is the same size as dp, by default, but it 
resizes based on the user's preferred text size.

For example when you specify spacing between two views use dp:
<Button android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/clickme"
    android:layout_marginTop="20dp" />

When spacing the text size always use sp:
<TextView android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:textSize="20sp" />



Convert dp units to pixels units :------------------------------
in some cases you will ned to express dimensions in dp and then convert them to pixels. The conversion of dp units to screen pixels is simple:

px= dp* (dpi/160)


The DisplayMetrics.density field specifies the scale factor you must use to convert units to pixels according to the current pixel density. On a medium-density screen, DisplayMetrocs
.density() equals 1.0
on  a high-density screen it equals 1.5 on an extra-high -density it equal 2.0 and on low-density screen it equal .75.

// The gesture threshold expressed in dp
private static final float GESTURE_THRESHOLD_DP = 16.0f;

// Get the screen's density scale
final float scale = getResources().getDisplayMetrics().density;
// Convert the dps to pixels, based on density scale
mGestureThreshold = (int) (GESTURE_THRESHOLD_DP * scale + 0.5f);

// Use mGestureThreshold as a distance in pixels...



Use pre-scaled configuration values:-----------------------------
you can use the ViewConfiguration class to access common distance speeds and times used by the Android systems. For instance the distance in pixels used by the framework as scroll
threshold can be obtained with getScaledTouchSlop():

private static final int GESTURE_THRESHOLD_DP = ViewConfiguration.get(myContext).getScaledTouchSlop();




Provide alternative bitmaps :---------------------------------------------
To provide good graphical qualities on device with different pixels densitites you should provide multiple version of each bitmap in your app -- one for each density bucket at a corresponding
resolution. Android must scale your bitmap so it occupies the same space visible on each screen resulting in scaling artifacts such as blurring.


Density qualifier	Description
ldpi	Resources for low-density (ldpi) screens (~120dpi).
mdpi	Resources for medium-density (mdpi) screens (~160dpi). (This is the baseline density.)
hdpi	Resources for high-density (hdpi) screens (~240dpi).
xhdpi	Resources for extra-high-density (xhdpi) screens (~320dpi).
xxhdpi	Resources for extra-extra-high-density (xxhdpi) screens (~480dpi).
xxxhdpi	Resources for extra-extra-extra-high-density (xxxhdpi) uses (~640dpi).
nodpi	Resources for all densities. These are density-independent resources. The system does not scale resources tagged with this qualifier, regardless of the current screen's density.
tvdpi	Resources for screens somewhere between mdpi and hdpi; approximately 213dpi. This is not considered a "primary" density group. It is mostly intended for televisions and most apps shouldn't need it—providing mdpi and hdpi resources is sufficient for most apps and the system will scale them as appropriate. If you find it necessary to provide tvdpi resources, you should size them at a factor of 1.33*mdpi. For example, a 100px x 100px image for mdpi screens should be 133px x 133px for tvdpi.
To create alternative bitmap drawables for different densities, you should follow the 3:4:6:8:12:16 scaling ratio between the six primary densities. For example, if you have a bitmap drawable that's 48x48 pixels for medium-density screens, all the different sizes should be:

36x36 (0.75x) for low-density (ldpi)
48x48 (1.0x baseline) for medium-density (mdpi)
72x72 (1.5x) for high-density (hdpi)
96x96 (2.0x) for extra-high-density (xhdpi)
144x144 (3.0x) for extra-extra-high-density (xxhdpi)
192x192 (4.0x) for extra-extra-extra-high-density (xxxhdpi)



Then place the generated image files in the appropriate subdirectory under res/ and the system will pick the correct one automatically based on the density of the device your app is 
running on:

res/
  drawable-xxxhdpi/
    awesome-image.png
  drawable-xxhdpi/
    awesome-image.png
  drawable-xhdpi/
    awesome-image.png
  drawable-hdpi/
    awesome-image.png
  drawable-mdpi/
    awesome-image.png


Then any time you reference @drawable/awesome image the ystem select the appropriate bitmap based on the screen's dpi provide a density-specific resource
for that density the system pick the next best match and scales it to fit the screen.




Put app icon in mipmap directories ;---------------------------------

Like all other bitmap assests you need to provides densities-specific version of you app icon. However some app launchers display your appicon as much as 25% larger than what's called 
for by the device's densities bucket.

For example, if a device's density bucket is xxhdpi and the largest app icon you provide is in drawable-xxhdpi, the launcher app scales up this icon, and that makes it appear less crisp. 
So you should provide an even higher density launcher icon in the mipmap-xxxhdpi directory. Now the launcher can use the xxxhdpi asset instead

Because your app icon might be scaled up like this, you should put all your app icons in mipmap directories instead of drawable directories. Unlike the drawable directory, all mipmap 
directories are retained in the APK even if you build density-specific APKs. This allows launcher apps to pick the best resolution icon to display on the home screen.

res/
  mipmap-xxxhdpi/
    launcher-icon.png
  mipmap-xxhdpi/
    launcher-icon.png
  mipmap-xhdpi/
    launcher-icon.png
  mipmap-hdpi/
    launcher-icon.png
  mipmap-mdpi/
    launcher-icon.png




=> Use vector graphics instead
An alternative to creating multiple density-specific versions of an image is to create just one vector graphic. Vector graphics create an image using XML to define paths and colors,
 instead of using pixel bitmaps. As such, vector graphics can scale to any size without scaling artifacts, though they're usually best for illustrations such as icons, not photographs.

Vector graphics are often provided as an SVG (Scalable Vector Graphics) file, but Android does not support this format so you must convert SVGs files to Android's vector drawable format.

You can easily convert an SVG to a vector drawable from Android Studio using Vector Asset Studio as follows:

In the Project window, right-click on the res directory and select New > Vector Asset.
Select Local file (SVG, PSD).
Locate the file you want to import and make any adjustments





























resource pointer to GradientDrawble







Resource reference :---

	In java R.drawable.filename
	in XML [package:]drawable/filename

Syntax:-

	<?xml version="1.0" encoding="utf-8"?>
<shape
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape=["rectangle" | "oval" | "line" | "ring"] >
    <corners
        android:radius="integer"
        android:topLeftRadius="integer"
        android:topRightRadius="integer"
        android:bottomLeftRadius="integer"
        android:bottomRightRadius="integer" />
    <gradient
        android:angle="integer"
        android:centerX="float"
        android:centerY="float"
        android:centerColor="integer"
        android:endColor="color"
        android:gradientRadius="integer"
        android:startColor="color"
        android:type=["linear" | "radial" | "sweep"]
        android:useLevel=["true" | "false"] />
    <padding
        android:left="integer"
        android:top="integer"
        android:right="integer"
        android:bottom="integer" />
    <size
        android:width="integer"
        android:height="integer" />
    <solid
        android:color="color" />
    <stroke
        android:width="integer"
        android:color="color"
        android:dashWidth="integer"
        android:dashGap="integer" />
</shape>


<shape>
this is the root element attributes

	
	android:shape
			Defines the types of shape valid values are:-
	
			
			Value		Desciption
			
			"rectangle"	A rectangle that fills the containing View. This is the default shape.
			"oval"		An oval shape that fits the dimensions of the containing View.
			"line"		A horizontal line that spans the width of the containing View. This shape requires the <stroke> element to define the width of the line.
			"ring"		A ring shape.	

			The following attributes are used only when android:shape="ring"

		android:innerRadius
		The radius for the inner part of the ring (the hole in the middle) as a dimension value or dimnesion rsources.


android:innerRadius
Dimension. The radius for the inner part of the ring (the hole in the middle), as a dimension value or dimension resource.

android:innerRadiusRatio
Float. The radius for the inner part of the ring, expressed as a ratio of the ring's width. For instance, if android:innerRadiusRatio="5", then the inner radius equals the ring's width divided by 5. This value is overridden by android:innerRadius. Default value is 9.

android:thickness
Dimension. The thickness of the ring, as a dimension value or dimension resource.

android:thicknessRatio
Float. The thickness of the ring, expressed as a ratio of the ring's width. For instance, if android:thicknessRatio="2", then the thickness equals the ring's width divided by 2. This value is overridden by android:innerRadius. Default value is 3.

android:useLevel
Boolean. "true" if this is used as a LevelListDrawable. This should normally be "false" or your shape may not appear



<corners>
Creates rounded corners for the shape. Applies only when the shape is a rectangle.
attributes:

android:radius
Dimension. The radius for all corners, as a dimension value or dimension resource. This is overridden for each corner by the following attributes.

android:topLeftRadius
Dimension. The radius for the top-left corner, as a dimension value or dimension resource.

android:topRightRadius
Dimension. The radius for the top-right corner, as a dimension value or dimension resource.

android:bottomLeftRadius
Dimension. The radius for the bottom-left corner, as a dimension value or dimension resource.

android:bottomRightRadius
Dimension. The radius for the bottom-right corner, as a dimension value or dimension resource.



<gradient>
Specifies a gradient color for the shape.
attributes:

android:angle
Integer. The angle for the gradient, in degrees. 0 is left to right, 90 is bottom to top. It must be a multiple of 45. Default is 0.
android:centerX
Float. The relative X-position for the center of the gradient (0 - 1.0).
android:centerY
Float. The relative Y-position for the center of the gradient (0 - 1.0).
android:centerColor
Color. Optional color that comes between the start and end colors, as a hexadecimal value or color resource.
android:endColor
Color. The ending color, as a hexadecimal value or color resource.
android:gradientRadius
Float. The radius for the gradient. Only applied when android:type="radial".
android:startColor
Color. The starting color, as a hexadecimal value or color resource.
android:type
Keyword. The type of gradient pattern to apply. Valid values are:
Value	Description
"linear"	A linear gradient. This is the default.
"radial"	A radial gradient. The start color is the center color.
"sweep"	A sweeping line gradient.
android:useLevel
Boolean. "true" if this is used as a LevelListDrawable



<size>
The size of the shape.
attributes:

android:height
Dimension. The height of the shape, as a dimension value or dimension resource.
android:width
Dimension. The width of the shape, as a dimension value or dimension resource.



<solid>
A solid color to fill the shape.
attributes:

android:color
Color. The color to apply to the shape, as a hexadecimal value or color resource.


<stroke>
A stroke line for the shape.
attributes:

android:width
Dimension. The thickness of the line, as a dimension value or dimension resource.
android:color
Color. The color of the line, as a hexadecimal value or color resource.
android:dashGap
Dimension. The distance between line dashes, as a dimension value or dimension resource. Only valid if android:dashWidth is set.
android:dashWidth
Dimension. The size of each dash line, as a dimension value or dimension resource. Only valid if android:dashGap is set.







11:04 AM 9/30/2019	Camera :------------------------------------
Android provides full access to the devices camera hardware so you can build a wide range of camera or vision-based apps.
If you just need a way for the user to capture a photo you can simply request an existing camera app to capture a photo and return it to you.




=>Take photos

1) Request the camera feature :-------------------

If an essential function of your application is taking pictures, then restrict its visibility on Google Play to devices that have a camera.
To advertise that your application depends on having a camera, put a <uses-feature> tag in your manifest file:

<manifest ... >
    <uses-feature android:name="android.hardware.camera"
                  android:required="true" />
    ...
</manifest>

If your application uses, but does not require a camera in order to function, instead set android:required to false

It's then your responsibility to check for the availability of the camera at runtime by calling has SystemFeature(PackageManager.FEATURE_CAMERA_ANY). If a camera is not available
you sholud then disable your camera features.
 


2) Take a photo with a camera app

Function that involves an intent to capture a photo


static final int REQUEST_IMAGE_CAPTURE = 1;
private void dispatchTakePictureIntent() {
    Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
        startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);
    }
}

Notice that the startActivityForResult() method is protected by a condition that calls resolveActivity(), which returns the first activity component that can handle the intent.
Performing this check is important because if you call startActivityForResult() using an intent that no app can handle, your app will crash. So as long as the result is not null,
it's safe to use the intent.

=>
By the help of android startActivityForResult() method we can get result from another activity.
By the help of Android startActivityForResult() method we can send information from one activity to another and vice-versa.
The android startActivityForResult method requires a result from the second activity (activity to be invoked).

In such case we need to override the onActivityResult method that is invoked automatically when second activity returns result.

=> Method Signature
There are two variants of startActivityForResult() method

public void startActivityForResult(Intent intent,int requestCode)
public void startActivityForResult(Intent intent,int requestCode,Bundle options)



3) Get the thumbnail :------------------------------------------

If the simple feat of taking a photo is not the culmination of your app's ambition, then you probably want to get the image back from the camera application and do something with it.

The Android Camera application encodes the photo in the return Intent delivered to onActivityResult() as a small Bitmap in the extras, under the key "data". 
The following code retrieves this image and displays it in an ImageView.

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == RESULT_OK) {
        Bundle extras = data.getExtras();
        Bitmap imageBitmap = (Bitmap) extras.get("data");
        imageView.setImageBitmap(imageBitmap);
    }
}


NOTE :- This thumbnail image from "data" might br good for icon but not a lot more. Dealing with a full-sized image takes a bit more work.



5) Save the full-size photo :---------------------------------

The Andorid camera application saves a full-size photo if you give it a file to save into.
You must provide a fully qualifies file name where the camera app should save the photo.
Generally any photos that the user captures with the device camera should be saved on the device in the public external storage so they are accessible by all apps.

The proper directory for shared photos is provided by getExternalStoragePublicDirectory(), with the DIRECTORY_PICTURE argument.
Because the directory provided by this method is shared among all apps, reading and writing to it requires the READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE permissio.

The write permission implicitly allows reading so if you need to write to the external storage then you need to request only one permission:


<manifest ...>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    ...
</manifest>



However if you's like the photos to remain private to your app only you can instead use the directory provided by getExternalFilesDir().
Files you save in the directory provided by getExternalFilesDir() or getFilesDir() are deleted when the user uninstall your app.


Once you decide the directory for the file, you need to create a collision-resistant file name.You may wish also to save the path in a member variable for later use.

Here's an example solution that returs a unique file name for a new photo using a date-time stamp:

String currentPhotoPath;

private File createImageFile() throws IOException {
    // Create an image file name
    String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    String imageFileName = "JPEG_" + timeStamp + "_";
    File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
    File image = File.createTempFile(
        imageFileName,  /* prefix */
        ".jpg",         /* suffix */
        storageDir      /* directory */
    );

    // Save a file: path for use with ACTION_VIEW intents
    currentPhotoPath = image.getAbsolutePath();
    return image;
}


With this method available to create a file for the photo you can now create and invoke the Intent like this:

static final int REQUEST_TAKE_PHOTO = 1;

private void dispatchTakePictureIntent() {
    Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    // Ensure that there's a camera activity to handle the intent
    if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
        // Create the File where the photo should go
        File photoFile = null;
        try {
            photoFile = createImageFile();
        } catch (IOException ex) {
            // Error occurred while creating the File
            ...
        }
        // Continue only if the File was successfully created
        if (photoFile != null) {
            Uri photoURI = FileProvider.getUriForFile(this,
                                                  "com.example.android.fileprovider",
                                                  photoFile);
            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);
            startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO);
        }
    }
}


Now you need to configure the FileProvider.In your app's manifest add a provider to your application:

<application>
   ...
   <provider
        android:name="android.support.v4.content.FileProvider"
        android:authorities="com.example.android.fileprovider"
        android:exported="false"
        android:grantUriPermissions="true">
        <meta-data
            android:name="android.support.FILE_PROVIDER_PATHS"
            android:resource="@xml/file_paths"></meta-data>
    </provider>
    ...
</application>


Make sure that the authorities string matches the second argument to getUriForFile(Context, String, File). In the meta-data section of the provider definition, you can see that the 
provider expects eligible paths to be configured in a dedicated resource file, res/xml/file_paths.xml. Here is the content required for this particular example:


<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="my_images" path="Android/data/com.example.package.name/files/Pictures" />
</paths>








Android allows you to manipulate images by adding different kinds of effects on the images you can easily apply image processing to add certain kinds of effects on images.
the effect could br brightness , darkness, grayscale conersion etc.
							Android provides Bitmap clss to handle image. This can be found under android.graphics.bitmap.

There are many ways through which you can instantiate bitmap. We are creating a bitmap of image from the imageView.

1) requestCode 	=> identifies which app returned these results. This is defined by you when you call startActivityForResult().
2) resultCode	=> informs you whether this app succeeded failed or something different
3) data		=> holds any information returned by this app. This may be null



4) Save the full-size photo

The Android camera application saves a full-size photo if you give it file to save into. You must provide a fully qualifies file name where the camera app should save the photo.

Generally, any photos that the user captures with the device camera should be saved on the device in the public external storage so they are accessible by all apps. 
The proper directory for shared photos is provided by getExternalStoragePublicDirectory()

with the DIRECTORY_PICTURES argument. Because the directory provided by this method is shared among all apps, reading and writing to it requires the 
READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE permissions, respectively. The write permission implicitly allows reading, so if you need to write to the external storage then you need to request only one permission

<manifest ...>
	<uses-permision adnroid:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
</manifest>



However if you'd like the photos to remain private to your app only you can instead use the directory provided by  getExternalfilesDir().
On Android 4.3 and lower, writing to this directory also requires the WRITE_EXTERNAL_STORAGE permission. Beginning with Android 4.4, the permission is no longer required 
because the directory is not accessible by other apps, so you can declare the permission should be requested only on the lower versions of Android by adding the maxSdkVersion

<manifest ...>
	<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
		android:maxSdkVersion="18"/>
</manifest...>




5) Once you decide the directory for the file, you need to create a collision-resistant file name. You may wish also to save the path in a member variable for later use.
Here's an example solution in a method that returns a unique file name for a new photo using a date-time stamp:



String currentPhotoPath;

private File createImageFile() throws IOException {
    // Create an image file name
    String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    String imageFileName = "JPEG_" + timeStamp + "_";
    File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
    File image = File.createTempFile(
        imageFileName,  /* prefix */
        ".jpg",         /* suffix */
        storageDir      /* directory */
    );

    // Save a file: path for use with ACTION_VIEW intents
    currentPhotoPath = image.getAbsolutePath();
    return image;
}




6) with this method available to create a file for the photo you can now create and invok the Intent like this

static final int REQUEST_TAKE_PHOTO = 1;

private void dispatchTakePictureIntent() {
    Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    // Ensure that there's a camera activity to handle the intent
    if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
        // Create the File where the photo should go
        File photoFile = null;
        try {
            photoFile = createImageFile();
        } catch (IOException ex) {
            // Error occurred while creating the File
            ...
        }
        // Continue only if the File was successfully created
        if (photoFile != null) {
            Uri photoURI = FileProvider.getUriForFile(this,
                                                  "com.example.android.fileprovider",
                                                  photoFile);
            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);
            startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO);
        }
    }
}



7) Now you need to configure the FileProvider. In your app's manifest add a provider to your application

<application>
   ...
   <provider
        android:name="android.support.v4.content.FileProvider"
        android:authorities="com.example.android.fileprovider"
        android:exported="false"
        android:grantUriPermissions="true">
        <meta-data
            android:name="android.support.FILE_PROVIDER_PATHS"
            android:resource="@xml/file_paths"></meta-data>
    </provider>
    ...
</application>














11:32 AM 9/13/2019	UI Layout :---------------------------------------------

The basin building block for user interface is a view object which is crated from the view class and occupies rectangular area on the screen and is responsible for drawing and event 
handling
View is  the base class for widget which are used to creae interactive UI components like button text fields etc.

ViewGroup is a subclass of View and provides invisible container that hold other Viewa or other ViewGrips and define thier layout properties.


Once your layout has created you can load the layout resource from youe application code in you Activity.onCreate() callback implementation as shown below:----------

public void onCreate(Bundle saveInstanceState)
{
	super.onCreate(saveInstanceState);
	setContentview(R.layout.activity_main);
}


Android layout types  :------------------------
there are number of Layout provided by Android which you use in almost all the Android application to provides different look and feel.

1	Linear Layout
LinearLayout is a view group that aligns all children in a single direction, vertically or horizontally.


2	Relative Layout
RelativeLayout is a view group that displays child views in relative positions.


3	Table Layout
TableLayout is a view that groups views into rows and columns.


4	Absolute Layout
AbsoluteLayout enables you to specify the exact location of its children.


5	Frame Layout
The FrameLayout is a placeholder on screen that you can use to display a single view.


6	List View
ListView is a view group that displays a list of scrollable items.


7	Grid View
GridView is a ViewGroup that displays items in a two-dimensional, scrollable grid.






=> View Identification :----------------------------
A View object may have a unique ID assigned to  it which will identify the View uniquely within the tree

	Syntax:----

			android:id="@+id/my_button"


1) The at-symbol (@) at the beginning of the string indicates that the XML parser should parse and expand the rest of the ID string and identify it as an ID resource.
2) The plus-symbol (+) means that this is a new resource name that must be created and added to our resources. To create an instance of the view object and capture it from the layout, use the following 


Android GridView shows items in two-dimensional scrolling grid (rows and column) and the grid items are not necessarily perdetermined but they automatically inserted to the 
layout using a ListAdapter.

An adapter actually bridge between UI compoennt and the data source that fill data into UI component. Adapter can be used to supply the data to like spinner list view grid view etc.

The ListView and GridView are subclass of AdapterView and they can be populated by binding them to an Adaptor which reterives data from an external source and created a View that represent each data entry.






	UI Control :----------------------------------

Input control are the interactive components in your app's user interface. ANdroid provides a wide variety of control you can use in your UI. such as buttons, text fields, seek bars, check box,
zoom buttons, toggle button and many more.

There are number of UI control provided by Android that allow you to build the graphical user interface for your app.

1) TextView
2) EditText
3) AutoCompleteTextView   //it is similar to the EditText except that it shows a list of completion suggestion automatically while the user is typing.
4) Button
5) ImageButton
6) CheckBox
7) ToggleButton
8) Radiobutton
9) Progress bar
10) Spinner
11) TimePicker
12) DatePicker


=> AutoCompleteTextView

The AutoCompleteTextView is a view that is similar to EditText except that it shows a list of completion suggestions automatically while the user is typing.
The list of suggestion is displayed in drop down menu. The user can choose an item from there to replace the content of edit box with.
The list of suggestion is obtained from a data adapter and appears only after a given number of characters defined by the threahold.



There are different steps that the user can perform the autocomplete text:---

The following code snippet shows how to create a text view which suggest various countries names while the user is typing:

 public class CountriesActivity extends Activity {
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
         setContentView(R.layout.countries);

         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,
                 android.R.layout.simple_dropdown_item_1line, COUNTRIES);
         AutoCompleteTextView textView = (AutoCompleteTextView)
                 findViewById(R.id.countries_list);
         textView.setAdapter(adapter);
     }

     private static final String[] COUNTRIES = new String[] {
         "Belgium", "France", "Italy", "Germany", "Spain"
     };
 }
 





String[] arr = { "Paries,France", "PA,United States","Parana,Brazil", "Padua,Italy", "Pasadena,CA,United States"};		//we define list of string like this
 


ArrayAdapter

public ArrayAdapter (Context context,int resource,T[] objects)
constructor will result in the underlying data collection being immutable so method such as clear() will throw an exception.


example 
ArrayAdapter<String> adapter=new ArrayAdapter<String>(this, android.R.layout.select_dialog_item,arr);

autocompleteview.setThreshold(2);
autocompleteview.setAdapter(adapter)



=> Parameters
1) context		context the current context this value must never be null.
2) resource	int the resource ID for a layout file containing a TextView to use  when instantiating views.
3) objects		T the object to represent in the ListView this value must never be null.




=====>

What is the difference between the AutoCompleteTextView and the Spinner
the difference between the AutoCompleteTextView is the combination of the EditText TextView and Spinner but it is not same as in the spinner 

spinner only showns the list of option form which we can  select the option the user can't put its own input in spinner , spinner is used where some set of input are fixed. 

<====


=>Spinner
Spinner allows you to select an item from a drop down menu.
For example when you are using Gmail application you would get drop down menu.



=> ImageButton
An ImageButton is an AbsoluteLayout which enables you to specify the exact location of its children. This shows a button with an image (instead of text) that can be  pressed or clicked by
the user.








	Android - Event Handling :-------------------------------------------------

Events are a useful way to collect data about user's interaction with interactive components of applications. Like button presses or screen touch etc.
The Android components of Applications. Like Button pressed or screen touch etc.
The Android framework maintains an events queue as first-in first out basis. You can capture these events in your program  and take appropriate action as per requirements.

There are following three concept related to Android Events Management :---------------

1) Event Listeners - 
An event listener is an interface in the View class that contains a single callback method. These methods will be called by the Android framework when the View to which the listener has 
been registered is triggered by user interaction with the item in the UI.

2) Event Listeners Registration - 
Event Registration is the process by which an Event Handler gets registered with an Event Listener so that the handler is called when the Event Listener fires the event.

3) Event Handlers - 
When an event happens and we have registered an event listener for the event, the event listener calls the Event Handlers, which is the method that actually handles the event


Example of EventHandler and EventListener :------------------------------------

if we take the example of event handler than it can be

public void onClick(View view)				//this is an event handler which handle the event on click some of the view control
{
}



setOnClickListener is a event listener which is register  the event when the UI control interact by the user.





		Event Listeners & Event Handlers  :-----------------------------------


Event Handler	Event Listener & Description
onClick()		OnClickListener()

This is called when the user either clicks or touches or focuses upon any widget like button, text, image etc. You will use onClick() event handler to handle such event.

onLongClick()	OnLongClickListener()

This is called when the user either clicks or touches or focuses upon any widget like button, text, image etc. for one or more seconds. You will use onLongClick() event handler to handle such event.

onFocusChange()	OnFocusChangeListener()

This is called when the widget looses its focus ie. user goes away from the view item. You will use onFocusChange() event handler to handle such event.

onKey()		OnFocusChangeListener()

This is called when the user is focused on the item and presses or releases a hardware key on the device. You will use onKey() event handler to handle such event.

onTouch()	OnTouchListener()

This is called when the user presses the key, releases the key, or any movement gesture on the screen. You will use onTouch() event handler to handle such event.

onMenuItemClick()	OnMenuItemClickListener()

This is called when the user selects a menu item. You will use onMenuItemClick() event handler to handle such event.

onCreateContextMenu()	onCreateContextMenuItemListener()

This is called when the context menu is being built(as the result of a sustained "long click)



	Event Listener Registration :-------------------
Event Registration is the process by which  an Event handler gets registered with an event listener so that handler is called when the event listener fires the event.
Three ways 
1) Using ananamous inner class
2) activity implementation the LIstener interface
3) Using layout file activity_main xml to specify event handler directly


Touch Mode
Users can interact with their devices by using hardware keys or buttons or touching the screen.Touching the screen puts the device into touch mode. 
The user can then interact with it by touching the on-screen virtual buttons, images, etc.You can check if the device is in touch mode by calling the View class’s isInTouchMode() 
method.


Focus
A view or widget is usually highlighted or displays a flashing cursor when it’s in focus. This indicates that it’s ready to accept input from the user.

isFocusable() - it returns true or false

isFocusableInTouchMode() - checks to see if the view is focusable in touch mode. (A view may be focusable when using a hardware key but not when the device is in touch mode)
















	=> Content Provider :-----------------------------



A content provider component supplies data from one application to others on request. Such request are handle by the methods of the ContentResolver.
A contentprovider can use different ways to store its data and the data can be stored in a database , in files or even a network.

A content provider access to central repository of data. A provider is a part of android application which often provides its own UI for working with the data.

Typically you work with content provider in one of two scenarios; 
you may want to implement code to access an existing content provider in another application
		
				or
you may want to create a new content provider in your application to share data with other application.


Overview :-
A content provider present data to external application as one or more tables that are similar to the table found in a realtional database.
A row represent an instance of some type of data the provider collects and each column in the row represent an individual piece of data collected for an instance.

A content provider coordinates access to the data storage layer in your application for a number of different  APIs and compoennts
1) Sharing access to your application data with other applications
2) sending data to a widget
3) returning custom saerch suggestion for your application through the search framework using SearchRecentSuggestionsProvider
4) Synchronizing application data with your server using an implementation of AbstractThreadedSyncAdapter
5) Loading data in your ui suing a CursorLoader



=> Accessing Provider

When you want to access data in a content provider you use the ContentResolver object in your application's Context to communicate with the provider as a client.
The ContentResolver object communicate with the provider object an instance of a class that implements ContentProvier.

The provider object receive data request from method performs the requested action and return the results.
The contentResolver method provides the basic CRUD (create, reterive , update and delete ) functions of persistent stroage.

A common pattern for accessing a ContentProvider from your UI uses a CursorLoader to run an asynchronous query in the background.The Activity or Fragment in your UI call a 
CursorLoader to the query, which in turn gets the ContentProvider using the ContentResolver. This allows the UI to continue to be available to the user while the query is running.


The column headers are column names that are stored in the provider to prefer to a row's local you refer to  its locale column. For this provider the _ID column serves as a primary key column
that the provider automatically maintains

To get a list of the words and their locales from the User Dictionary Provider, you call ContentResolver.query(). 
/*this code runs in the background which call the content provider
The query() method calls the ContentProvider.query() method defined 
*/

by the User Dictionary Provider. The following lines of code show a ContentResolver.query()


// Queries the user dictionary and returns results
cursor = getContentResolver().query(
    UserDictionary.Words.CONTENT_URI,   // The content URI of the words table
    projection,                        // The columns to return for each row
    selectionClause,                   // Selection criteria
    selectionArgs,                     // Selection criteria
    sortOrder);                        // The sort order for the returned rows



how the argument sto query(Uri, projection,selection,selectionArgs,sortOrder) match an SQL SELECT statement

query() argument		SELECT keyword/parameter			Notes

Uri			FROM table_name				Uri maps to the table in the provider named table_name
projection		col,col,col,......				projection is an array of columns that should be included for rwo reterived.
selection			WHERE col=value				selection specifies the criteria for selecting rows.
selectionAgrs		No args equivalent selection argument
sortorder			ORDER BY COL,COL,			sortOrder specifies the order in which rows appear in the returns Cursour.




Content URIs
A content URI is a URI that identifies data in a provider. Content URIs include the symbolic name of the entire provider (its authority) and a name that points to a table (a path). 
Content URIs
A content URI is a URI that identifies data in a provider. Content URIs include the symbolic name of the entire provider (its authority) and a name that points to a table (a path). When you call a client method to access a table in a provider, the content URI for the table is one of the arguments.

In the preceding lines of code, the constant CONTENT_URI contains the content URI of the user dictionary's "words" table. The ContentResolver object parses out the URI's authority, and uses it to "resolve" the provider by comparing the authority to a system table of known providers. The ContentResolver can then dispatch the query arguments to the correct provider.

The ContentProvider uses the path part of the content URI to choose the table to access. A provider usually has a path for each table it exposes.
content://user_dictionary/words


Many providers allow you to access a single row in a table by appending an ID value to the end of the URI. For example, to retrieve a row whose _ID is 4 from user dictionary, you can use this content URI:
Uri singleUri = ContentUris.withAppendedId(UserDictionary.Words.CONTENT_URI,4);




Retrieving data from the provider :---------------------------------
This section describes how to reterive data from a provider using the User Dictionary Provider as an example.

To reterive data from a provider follow these basic steps:
1) Request the read access permission for the provider.
2) Define the code that send a query to the provider

=> Requesting read access permission:-
To reterive data from a provider your application needs read acces permisssion for the provider you can't request this permissioon at run timeinstead you have to specify that you need this permission
in your manifest file using the
				<uses-permission>


=> Contructing the query
The next step in reteriving data from a provider is to construct a query.This snippet defines some varible for accessing the user DIctionary Provider.

// A "projection" defines the columns that will be returned for each row
String[] mProjection =
{
    UserDictionary.Words._ID,    // Contract class constant for the _ID column name
    UserDictionary.Words.WORD,   // Contract class constant for the word column name
    UserDictionary.Words.LOCALE  // Contract class constant for the locale column name
};

// Defines a string to contain the selection clause
String selectionClause = null;

// Initializes an array to contain selection arguments
String[] selectionArgs = {""};




The expression that specifies the rows to retrieve is split into a selection clause and selection arguments. The selection clause is a combination of logical and Boolean expressions, 
column names, and values (the variable mSelectionClause). If you specify the replaceable parameter ? instead of a value, the query method retrieves the value from the selection 
arguments array (the variable mSelectionArgs).

If you specify the replaceable parameter ? instead of a value, the query method retrieves the value from the selection arguments array (the variable mSelectionArgs).






Displaying query results :-

The ContentResolver.query() client method always returns a Cursor containing the columns specified by the query's projection for the rows that match the query's selection criteria. 
A Cursor object provides random read access to the rows and columns it contains. Using Cursor methods, you can iterate over the rows in the results, determine the data type of each 
column, get the data out of a column, and examine other properties of the results. Some Cursor implementations automatically update the object when the provider's data changes, or 
trigger methods in an observer object when the Cursor changes, or both.

If no rows match the selection criteria, the provider returns a Cursor object for which Cursor.getCount() is 0 (an empty cursor).

If an internal error occurs the results of the query depend on the particular provider. It may show coose to return null or it may throw an Exception.
Since a Cursor is a list rows a good way to display the content of a Cursorm is to link it to a Listview via a SImple CursorAdater.


// Defines a list of columns to retrieve from the Cursor and load into an output row
String[] wordListColumns =
{
    UserDictionary.Words.WORD,   // Contract class constant containing the word column name
    UserDictionary.Words.LOCALE  // Contract class constant containing the locale column name
};

// Defines a list of View IDs that will receive the Cursor columns for each row
int[] wordListItems = { R.id.dictWord, R.id.locale};

// Creates a new SimpleCursorAdapter
cursorAdapter = new SimpleCursorAdapter(
    getApplicationContext(),               // The application's Context object
    R.layout.wordlistrow,                  // A layout in XML for one row in the ListView
    mCursor,                               // The result from the query
    wordListColumns,                      // A string array of column names in the cursor
    wordListItems,                        // An integer array of view IDs in the row layout
    0);                                    // Flags (usually none are needed)

// Sets the adapter for the ListView
wordList.setAdapter(cursorAdapter);


=> Getting data from query result :----------------
Rather than simply displaying query results you can use them for other task.
For example, you can retrieve spellings from the user dictionary and then look them up in other providers. To do this, you iterate over the rows in the Cursor:

// Determine the column index of the column named "word"
int index = mCursor.getColumnIndex(UserDictionary.Words.WORD);

/*
 * Only executes if the cursor is valid. The User Dictionary Provider returns null if
 * an internal error occurs. Other providers may throw an Exception instead of returning null.
 */

if (mCursor != null) {
    /*
     * Moves to the next row in the cursor. Before the first movement in the cursor, the
     * "row pointer" is -1, and if you try to retrieve data at that position you will get an
     * exception.
     */
    while (mCursor.moveToNext()) {

        // Gets the value from the column.
        newWord = mCursor.getString(index);

        // Insert code here to process the retrieved word.

        ...

        // end of while loop
    }
} else {

    // Insert code here to report an error if the cursor is null or the provider threw an exception.
}



=> Content provider permissions:------------------
A provider's application can specify mermission that other aoolication must have in order to access provider's data.

These permissions ensure that the user knows what data an application will try to access. Based on the provider's requirements, other applications request the permissions they need 
in order to access the provider


As noted previously, the User Dictionary Provider requires the android.permission.READ_USER_DICTIONARY permission to retrieve data from it. The provider has the separate android.permission.WRITE_USER_DICTIONARY permission for inserting, updating, or deleting data.



Inserting , updating and deleting data:-------------------------
In the same way that you reterivieing data from  a provider you also use the interaction between a provider client and the provider's ContentProvider to modify data.


Inserting data :-
to insert data into a provider you call the Contentresolver.insert() method .This method insert a new  row into the provider and return content uri for that row.

// Defines a new Uri object that receives the result of the insertion
Uri newUri;

...

// Defines an object to contain the new values to insert
ContentValues newValues = new ContentValues();

/*
 * Sets the values of each column and inserts the word. The arguments to the "put"
 * method are "column name" and "value"
 */
newValues.put(UserDictionary.Words.APP_ID, "example.user");
newValues.put(UserDictionary.Words.LOCALE, "en_US");
newValues.put(UserDictionary.Words.WORD, "insert");
newValues.put(UserDictionary.Words.FREQUENCY, "100");

newUri = getContentResolver().insert(
    UserDictionary.Words.CONTENT_URI,   // the user dictionary content URI
    newValues                          // the values to insert
);


The column in this object don't need to have same data type and if you don't want to specify a value at all you can set a columnto null using  Contentvalus.putNull();





=> Updating Data :-
To update a row you use a ContentValues object with the updated values just as you do with an insertion, adn seleciton criteria just as you can do with query
The client method you use is ContentResolver.update(). You only need to add values to the ContentValues object for coluns you are updating.
I f you want to clear the contents of a column set the values to null.



// Defines an object to contain the updated values
ContentValues updateValues = new ContentValues();

// Defines selection criteria for the rows you want to update
String selectionClause = UserDictionary.Words.LOCALE +  " LIKE ?";
String[] selectionArgs = {"en_%"};

// Defines a variable to contain the number of updated rows
int rowsUpdated = 0;

...

/*
 * Sets the updated value and updates the selected words.
 */
updateValues.putNull(UserDictionary.Words.LOCALE);

rowsUpdated = getContentResolver().update(
    UserDictionary.Words.CONTENT_URI,   // the user dictionary content URI
    updateValues,                      // the columns to update
    selectionClause,                   // the column to select on
    selectionArgs                      // the value to compare to
);


=> Deleting data:------------
Deleting ows is similar to reteriving row data you specify selection criteria for the rows you want to delete and the client method returns the number of deleted rows.
The following snippet deletes rows whose appid matches "user". The method returns of deleting rows.


// Defines selection criteria for the rows you want to delete
String selectionClause = UserDictionary.Words.APP_ID + " LIKE ?";
String[] selectionArgs = {"user"};

// Defines a variable to contain the number of rows deleted
int rowsDeleted = 0;

...

// Deletes the words that match the selection criteria
rowsDeleted = getContentResolver().delete(
    UserDictionary.Words.CONTENT_URI,   // the user dictionary content URI
    selectionClause,                   // the column to select on
    selectionArgs                      // the value to compare to
);


















11:11 AM 9/17/2019      Styles and Themes :------------------------------------------------------------

Styles and theme on Android allow you to separate the detailes of your app design from the UI structure and behaviour similar to stylesheets in web design.
A style is a collection of attributes that specify the appearance for a single View. AStyle can specify attributes such as font color, font size, background, and much more.

A theme is a type of style that's applied to an entire app activity or view hierarchy--not just an individual view. When you apply your style as a theme every view in the app or activity
applies each style sttribute that it supports. Themes can also apply styles to non-view element such as the status bar and window background.

Styles and themes are declared in a style resource file in res/values/, usually named styles.xml.


=>  Create and apply  s tyle:----------------------------
To create a new style or theme open your project's res/values/styles.xml file.For each style you want to create follow these steps:

1) Add a <style> element with a name that uniquely identifies the style
2) Add an <item> element for each style attribute you want to define.

The name in each item specifies an attribute you would otherwise use as an XML attribute in your layout. The value in the <item> element is the value for that attribute.

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="GreenText" parent="TextAppearance.AppCompat">
        <item name="android:textColor">#00FF00</item>
    </style>
</resources>


you can apply the style to a view as follows:

<TextView
	style="@style/GreenText"
/>



However instead of applying a style to individual views you'll usually apply styles as a theme for your entire app, activity or collection of views.


=> Extend and customize a style :-------------------------------------

When creating your own styles you should always extend an existing style from the framework or supprt library so that you maintain compatibility wuth platform UI style. 
To extend a style, specify the style you want to extend with the parent attribute. You can then override the inherited style attributes and add new ones.

For example, you can inherit the Android platform's default text appearance and modify it as follows:


<style name="GreenText" parent="@android:style/TextAppearance">
    <item name="android:textColor">#00FF00</item>
</style>


However, you should always inherit your core app styles from the Android Support Library. The styles in the support library provide compatibility with Android 4.0 (API level 14) and 
higher by optimizing each style for the UI attributes available in each version. The support library styles often have a name similar to the style from the platform, but with AppCompat
 included.

To inherit styles from a library or your own project, declare the parent style name without the @android:style/ part shown above. For example, the following example inherits text 
appearance styles from the support library:


<style name="GreenText" parent="TextAppearance.AppCompat">
    <item name="android:textColor">#00FF00</item>
</style>



You can also inherit styles (except those from the platform) by extending a style's name with a dot notation, instead of using the parent attribute. That is, prefix the name of your style 
with the name of the style you want to inherit, separated by a period. You should usually do this only when extending your own styles, not styles from other libraries. For example, the 
following style inherits all styles from the GreenText style above and then increases the text size


<style name="GreenText.Large">
    <item name="android:textSize">22dp</item>
</style>



Apply a style as a theme :-------------------------------------------------
you can create a theme the same way you create styles. The difference is how you apply it: instead of applying a style with the style attribute on a view you apply a theme with the android:theme
attribute on either the <application> tag or on <activity> tag in the AndroidManifest.xml file.

for example:-

<manifest>
	<aplication android:theme="@style/Theme.AppCompat"></application>
</manifest>


And here's how tp apply the "light" theme to just one activity:

<manifest ... >
    <application ... >
        <activity android:theme="@style/Theme.AppCompat.Light" ... >
        </activity>
    </application>
</manifest>
















11:17 AM 9/19/2019	Device Compatibility :------------------------------------------

Android is designed to run on many different types of device , from phones to tablets and televisions. As a developer the range of device provides a huge potential audience for your app.
In order for your app to be successful on all these devices it should tolerate and provides a flexible user interface that adapts to different screen configuration.



What does compatibility mean :---------------------------

As you read more about Android development you'll probably encounter the term "compatibitlity" in various situations.
There are two types of compaitbility
1) Device Compatibility
2) App Compatibility


1) =>
Because Android is open source project any hardware manufacturer can build a device that runs the Android operating system. Yet a  "device is Android compatible" only if it can correctly 
run apps written for the Android execution environment.
Th exact details details of the Android execution environment are defined by the Android compatibility programand each device must pass the Compatibility Test Suit (CTS) in order to be
considered compatible.

As an app developer you don't need to worry about whether a device is Andorid compatible because only device that are Android compatible include Google Play Store.So you can rest
assured that user who install your app from Google Play Store are using an Android compatible device.

2) 
However, you do need to consider whether your app is compatible with each potential device configuration. Because Android runs on a wide range of device configurations, some 
features are not available on all devices. For example, some devices may not include a compass sensor. If your app's core functionality requires the use of a compass sensor, then your 
app is compatible only with devices that include a compass sensor.



Controlling your app's availability to device :----------------------
Android support a variety of features your app can leverage through platform APIs. Some features are hardware-based (such as a compass sensor), some are software-based (such as app widgets), and some are dependent on the platform version.
Not every device support every featture sonyou may need to control your app's availability to device based on your app's required features.

To achieve the largest user-base posiible for your app you should strive to support as many device configurations as possible using a single APK. in most situations you can do so by disabling
optional featues at runtime and providing app resources with alternatives for different configurations (such as different layouts for different screen sizes).
If necessary however you can restrict your app's availability to devices through Google Play Store based on the following device characteristics.

=> Device features
=> Platform version
=> Screen Configuration


Device features :---------------

In order for you to manage your app’s availability based on device features, Android defines feature IDs for any hardware or software feature that may not be available on all devices. 
For instance, the feature ID for the compass sensor is FEATURE_SENSOR_COMPASS and the feature ID for app widgets is FEATURE_APP_WIDGETS.
If necessary, you can prevent users from installing your app when their devices don't provide a given feature by declaring it with a <uses-feature> element in your app's manifest file.
For example, if your app does not make sense on a device that lacks a compass sensor, you can declare the compass sensor as required with the following manifest tag:

<manifest ... >
    <uses-feature android:name="android.hardware.sensor.compass"
                  android:required="true" />
    ...
</manifest>


Google Play Store compares the features your app requires to the features available on each user's device to determine whether your app is compatible with each device. If the device 
does not provide all the features your app requires, the user cannot install your app.



Platform version :-------------------------------
Different device may run different version of the Android platform such as Android 4.0 or Android 4.4 each successive platform version often adds new APIs not available in the previous
version.
To indicate which set of APIs are available each platform version specifies an API Level. For instance Android 1.0 is API level 1 and Android 4.4 is API level 19.


The API level allows you to declare the minimum version with which your app is compatible, using the <uses-sdk> manifest tag and its minSdkVersion attribute. For example, the Calendar
Provider APIs were added in Android 4.0 (API level 14). If your app cannot function without these APIs, you should declare API level 14 as your app's minimum supported version.

The minSdkVersion attribute declares the minimum version with which your app is compatible and the targetSdkVersion attribute declares the highest version on which you've optimized
your app.

However, beware that attributes in the <uses-sdk> element are overridden by corresponding properties in the build.gradle file. So if you're using Android Studio, you must specify the
minSdkVersion and targetSdkVersion values there instead:


android {
  defaultConfig {
    applicationId 'com.example.myapp'

    // Defines the minimum API level required to run the app.
    minSdkVersion 15

    // Specifies the API level used to test the app.
    targetSdkVersion 28

    ...
  }
}




However, if your app uses APIs added in a more recent platform version, but does not require them for its primary functionality, you should check the API level at runtime and gracefully
degrade the corresponding features when the API level is too low. In this case, set the minSdkVersion to the lowest value possible for your app's primary functionality, then compare the
current system's version, SDK_INT, to one the codename constants in Build.VERSION_CODES that corresponds to the API level you want to check. For example:

if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
    // Running on something older than API level 11, so disable
    // the drag/drop features that use <code><a href="/reference/android/content/ClipboardManager.html">ClipboardManager</a></code> APIs
    disableDragAndDrop();
}




Scren Configurations :-------------------------------
Android runs on device of various sizes from phones to tablets and TVs. Inorder to categorize devices by their screen types Android defines teo characteristics for each device

A) screen size (the physical size of the screen)
B) screen density (the physical density of the pixels on th screen known as DPI)

To simplify the different configurations, Android generalizes these variants into groups that make them easier to target:

screen size  	=>  	our generalized sizes: small, normal, large, and xlarge.
screen density 	=>	And several generalized densities: mdpi (medium), hdpi (high), xhdpi (extra high), xxhdpi (extra-extra high), and others.




Screen Size :-------------------------------
The screen size is the visible space provided for your app UI.

Flexible Layouts :---------------------
B default Android resizes your app layout to fit the current screen. To ensure your layout resizes well for even small variations in screen size you need to implement your layout with 
flexibility in mind. The core principle you must follow is to avoid hard-coding the position and szie of your UI components. Instead allow view  sizes to stretch and specify view positions
relative to the parent view or other sibling views so your intended order and relative sizes reamin the same as the layout grows.


Alternative Layouts :---------------------------------
A flexible layout is very important but you should also design different layouts that optimize the user experience for the available space on different device such as phones and tablets.
So ANdroid allows you to provide alternative layout files that the system applies at runtime based on the current device's screen size.


Stretchble image :------------------------
 Because your layout should stretche to fit the current screen so too should the bitmap that you attach to any of the layout views. However a streching an ordinary bitmap in arbitrary
direction can result in strange scaling artifacts and skewed images.

To solve this Android support nine-patch bitmaps in which you specify small pixel region that are stretched ---the rest of the image remain unscaled.



Pixel densities :---------------------------------
The pixel density is the  number of pixels within a physical area of the screen and is referred to an dpi (dots per inch). This is different from the resolution which is the total number of
pixels on a screen.


Density independence :-------------------------------

Your app achieves "density independence" when it preserves the physical size (from the user's point of view) of your UI design when displayed on screens with different pixel 
densities (as shown in figure 2). Maintaining density independence is important because, without it, a UI element (such as a button) might appear larger on a low-density screen 
and smaller on a high-density screen (because when the pixels are larger—as shown in figure 2—a few pixels can go a long way).

The Android system helps you achieve density independence by providing density-independent pixels (dp or dip) as a unit of measurement that you should use instead of pixels (px).




Alternative bitmaps :--------------------

To ensure your images appear at their best on all screens, you should provide alternative bitmaps to match each screen density. For example, if your app provides bitmaps only for 
medium density (mdpi) screens, Android scales them up when on a high-density screen so that the image occupies the same physical space on the screen. This can cause visible scaling
artifacts in bitmaps. So your app should include alternative bitmaps at a higher resolution.



Vector graphics :-------------------------
For simple types of images (usually icons), you can avoid creating separate images for each density by using vector graphics. Because vector graphics define the illustration with
geometric line paths instead of pixels, they can be drawn at any size without scaling artifacts.







=> Support Different screen sizes :-

Android devices come in all shapes and sizes, so your app's layout needs to be flexible. That is, instead of defining your layout with rigid dimensions that assume a certain screen size and
aspect ratio, your layout should gracefully respond to different screen sizes and orientations.

By Supporting as amny screen as possible your app can be made available to the greatest number of user with different devices using a single APK. Additionally making your app
flexible for different sizes ensures that your app can handle window configuration changes on the device such as when the user enables multi-window mode.

This page shows you how to support different screen size with the following techniques:
=> use view dimension that allow the layout to resize.
=> create alternative UI layouts according to the screen configuration
=> provide bitmap that can stretch with the views



=> Create a flexible layout

No matter what hardware profile you want to support first, you need to create a layout that is responsive to even small variations in screen size.


Use ConstraintLayout  =>
The best way to create a responsive layout for different screen sizes is to use ConstraintLayout as the base layout in your UI. ConstraintLayout allows you to specify the position and size
for each view according to spatial relationships with other views in the layout. This way, all the views can move and stretch together as the screen size changes.


Avoid hard-coded sizes :--------------------

To ensure that your layout is flexible and adapts to different screen sizes you should use "wrap_content" and "match_parent" for the width and height of most view component instead
of hard-coded sizes.

"wrap_content"	=>	tells the view to set its size to whatever is necessary to fit the content within that view.

"match_parent"	=>	makes the view expand to as much as possible with in the parent view.

Example =>
<TextView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="@string/lorem_ipsum" />


=> The width of the text view using "match_parent" adjust as the screen width changes with device orientation.

When using ConstraintLayout you should not use match_parent instead set the dimension to 0dp enable a special behaviour called "match_constraints" which is generally the same as
what you expect from match_parent. for more information see how to adjust the view size in ConstraintLayout.
