10:31 AM 9/3/2019

	Intent :------------

public class Intent extends Object implements Parcelable, Cloneable

Parcelable => Interface for classes whose instance can be written to and restored from a Parcel. Classes implementing the Parcelable interface must also have a non-null static field caled 
	       CREATOR of a type that implements the Parcelable.Creator interface
Parcel	 => Container for a message (data and object references) that can be sent through an IBinder.

Cloneable => A class implements the Cloneable interface to indicate to the Object.clone() method that it is legal for that method to make a field-for-field copy of instance of that class.
		creates and returns a copy of this object.


An Intent is an abstract description of an operation to be performed. It can be used with
Intents are asynchronus message which allow Android component to request functionality from other component of the Android System.

startActivity(Intent) 	=> to launched an Activity
broadcastIntent	=> to send it to any interested  BroadcastReceiver components
startService(Intent)	/ bindService(Intent, ServiceConnection, int)	=> to communicate with background.

Intent has been used to call another acitivity
Its most significant use  is in the launching of activites, where it can be throught of as the glue between activites.
It is basically a passive data structure holding an abstract description of an action to be performed.

Intent Structure :--------------
The primary pieces of information in an intent are :

1) Action	:- the general action to be performed such as  ACTION_VIEW,  ACTION_EDIT,  ACTION_MAIN

2) Data	:- the data to operate on such as a person records in the contact database, expressed as a Uri.

Some of the Example of action/data pair are: --------

1) ACTION_VIEW content://contacts/people1 => display information about the person whose identifier is 1
2) ACTION_DIAL tel:123	=> display the phone dialer with the given number filled in 


Inaddition to these primary attributes there are number of secondary attribute that you can also include with an intent:-

3) Category	:- gives additional information about the action to execute. For example CATEGORY_LAUNCHER means it should appear in the Launcher as a top-level application.

4) Type		:- specifies an explicity type (a MIME type) of the intent data

5) Component	:- specifies an explicit name of a component class to use for the intent >Normally this is determined by looking at the other information in the intent (action, data/type and categories)
		and matching that with a component that can handle

6) Extras		:- this is a Bundle of any additional information.this can be used to provide extended information to the component.
		For example if we have a action to send an e-mail message we could include extra pieces of data here to supply a subject body etc.


In Android the reuse of other application components is a concept knowns as task. An application can access other Android components to achieve a task.
For Example from a component of your application you can trigger another component in the Android system which manage photos, even it thif component is not part of your application. 
In this component you select a photo and return to your application to use the selected photo.


 => Here are some examples of other operations you can specify as intents using these additional parameters:

ACTION_MAIN with category CATEGORY_HOME -- Launch the home screen.

ACTION_GET_CONTENT with MIME type vnd.android.cursor.item/phone -- Display the list of people's phone numbers, allowing the user to browse through them and pick one and return it to the parent activity.





Intent  Resolution :---------------
There are two primary forms of intens you will use

1) Explicit Intent
2) Implicit Intent


Explicit Intent :-----------
In Android Explicit Intent explicitly specify the name of component to be invoked by an activity and we use explicit intents to start a component in out own app.
By using explicit intents we can send or share data / content from one activity to another activity based on your requirement
Explicit intent going to be connected internal world of application suppose if you wants to connect one activity to another activity we can do this quoteby explicit intent.
To create an Explicit Intent we need to define the component name for Intent object.



Implicit Intent :-----------
These intent do not name a target and the field of the component name is left blank. Implicit intents are often used to activate component in other application.
It is not specified a component instead they must include enough information for the system to determine which of the available component is best to run for that intent.

When using implecit intent given such an arbitaray intent we need to know what to do with it.This is handle by the process of intent resolution which maps an intent to an Activity
BroadCastreceiver or Service 

		The intent resolution mechanism basically revolve around matching an intnet against all of <intent-filter> descriptions in the installation package.

There are three pieces of information in the intent that are used for resolution: the action , type , and category

Intent-filter :------------------
Intent Filter is an expression in app's manifest file (ActivityManifest.xml) and it is used to specify the type of intent that the component would like to receive. In case if we create Intent filter 
for an activity there is a possibility for other apps to start our activity by sending a certain type of intent.
											otherwise the activity can be started only by an explicit intent.




There are three intent characteristics you can filter on the action , data and categories. For each of these characteriscs you can provides multiple possible matching values (via addAction(String),
 addDataType(String), addDataScheme(String), addDataSchemeSpecificpart(String ,int), addDataAuthority(String,String), addDataPath(String,int) and addCategory(String), respectively)


Filter Rule :-----------
A match is based on the following rule.Note that for an IntentFilter to match an Intent three condition must hold the action and category must match and the data (both data type and data 
scheme+authority+path if specified) must match

=> Action matches if any of the given values match the Intent action; if the filter specifies no actions, then it will only match Intents that do not contain an action.

=> Data Type matches if any of the given values match the Intent type. The Intent type is determined by calling Intent#resolveType. A wildcard can be used for the MIME sub-type, in both 
the Intent and IntentFilter, so that the type "audio/*" will match "audio/mpeg", "audio/aiff", "audio/*", etc. Note that MIME type matching here is case sensitive, unlike formal RFC MIME
types! You should thus always use lower case letters for your MIME types.

=> Data Scheme matches if any of the given values match the Intent data's scheme. The Intent scheme is determined by calling Intent#getData and Uri.getScheme() on that URI.
Note that scheme matching here is case sensitive, unlike formal RFC schemes! You should thus always use lower case letters for your schemes.

=> Data Scheme matches if any of the given values match the Intent data's scheme. The Intent scheme is determined by calling Intent#getData and Uri.getScheme() on that URI.
 Note that scheme matching here is case sensitive, unlike formal RFC schemes! You should thus always use lower case letters for your schemes.





Generally the Intent Filter ( <intent-filter> ) whatever we define in manifest file can be nested in the corresponding app components and we can specify the type of intent to accept using these
three elements.

<Action>It define the name of an intent action to be accepted and it must be a literal string value of an action not the class contant.

<categories> it define the name of an intent category to be accepted and it must be the literal string value of an action not the class constant.

<data>
It defines the type of data to be accepted and by using one or more attributes we can specify various aspects of the data URI (scheme, host, port, path) and MIME type


Intent Filter in Manifest File 
Following is the code snippet of defining an activity with Intent Filter (<intent-filter>) in Android Manifest file (AndroidManifest.xml) like as shown below.

 

<activity android:name=".MainActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
        <data android:mimeType="text/plain"/>
    </intent-filter>
</activity>

We can define a filter with multiple instances of <action>, <category> or <data> elements and we need to make sure that component can handle all the combinations of filter elements.



:


Notification :--------------------------------------------------
A notification is a message that android display outside your app's UI to provide the user with remainders communication from other people or other timely information from your app.

Appearance on a Device :-
 Notification appear to user in different locations and formats such as an icon in the status bar a more detailed entry in the notification drawer as a bdge on the app's icon and on paired wearable automatically.

1) Staus bar notification drawer
When you issue a notification, it first appears as an icon in the status bar.
Users can swipe down on the status bar to open the notification drawer, where they can view more details and take actions with the notification.


2) Heads-up notification
Beginning with Android 5.0, notifications can briefly appear in a floating window called a heads-up notification. This behavior is normally for important notifications that the user should 
know about immediately, and it appears only if the device is unlocked.

The heads-up notification appears the moment your app issues the notification and it disappears after a moment, but remains visible in the notification drawer as usual.

Example conditions that might trigger heads-up notifications include the following:

The user's activity is in fullscreen mode (the app uses fullScreenIntent).
The notification has high priority and uses ringtones or vibrations on devices running Android 7.1 (API level 25) and lower.
The notification channel has high importance on devices running Android 8.0 (API level 26) and higher.


4) Lock screen
Beginning with Android 5.0, notifications can appear on the lock screen.
You can programmatically set the level of detail visible in notifications posted by your app on a secure lock screen, or even whether the notification will show on the lock screen at all.
Users can use the system settings to choose the level of detail visible in lock screen notifications, including the option to disable all lock screen notifications. Starting with Android 8.0, 
users can choose to disable or enable lock screen notifications for each notification channel.

5) App icon badge
In supported launchers on devices running Android 8.0 (API level 26) and higher, app icons indicate new notifications with a colored "badge" (also known as a "notification dot") 
on the corresponding app launcher icon.

Users can long-press on an app icon to see the notifications for that app. Users can then dismiss or act on notifications from that menu, similar to the notification drawer.


6) Wear OS devices
If the user has a paired Wear OS device, all your notifications appear there automatically, including expandable detail and action buttons.

You can also enhance the experience by customizing some appearances for the notification on wearables and provide different actions, including suggested replies and voice input 
replies. For more information, see how to add wearable-specific features to your notification.


Notification anatomy :-------------------
The design of a notification is determined by system templates—your app simply defines the contents for each portion of the template.


Notification actions
Although it's not required, every notification should open an appropriate app activity when tapped. In addition to this default notification action, you can add action buttons that complete
 an app-related task from the notification (often without opening an activity)

Expandable notification
By default, the notification's text content is truncated to fit on one line. If you want your notification to be longer, you can enable a larger text area that's expandable by applying an 
additional template


	Notification updates and groups :----------------------

To avoid bombarding your users with multiple or redundant notifications when you have additional updates, you should consider updating an existing notification rather than issuing a 
new one, or consider using the inbox-style notification to show conversation updates.

However, if it's necessary to deliver multiple notifications, you should consider grouping those separate notifications into a group (available on Android 7.0 and higher). 
A notification group allows you to collapse multiple notifications into just one post in the notification drawer, with a summary. The user can then expand the notification to 
reveal the details for each individual notification.



	Notification channels
Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel or it will not appear. By categorizing notifications into channels, users can disable specific notification 
channels for your app (instead of disabling all your notifications), and users can control the visual and auditory options for each channel—all from the Android system settings (figure 11).


	Notification importance :-------------------
Android uses the importance of a notification to determine how much the notification should interrupt the user (visually and audibly). The higher the importance of a notification, 
the more interruptive the notification will be.

On Android 8.0 (API level 26) and above, importance of a notification is determined by the importance of the channel the notification was posted to. Users can change the importance
 of a notification channel in the system settings (figure 12). On Android 7.1 (API level 25) and below, importance of each notification is determined by the notification's priority.



The possible importance levels are the following:

Urgent: Makes a sound and appears as a heads-up notification.
High: Makes a sound.
Medium: No sound.
Low: No sound and does not appear in the status bar.


	Do Not Disturb mode
Starting in Android 5.0 (API level 21), users can enable Do Not Disturb mode, which silences sounds and vibration for all notifications. Notifications still appear in the system UI as
 normal, unless the user specifies otherwise.

There are three different levels available in Do Not Disturb mode:

Total silence: blocks all sounds and vibrations, including from alarms, music, videos, and games.
Alarms only: blocks all sounds and vibrations, except from alarms.
Priority only: users can configure which system-wide categories can interrupt them (such as only alarms, reminders, events, calls, or messages). For messages and calls, users can also 
choose to filter based on who the sender or caller is



Notifications for foreground services
A notification is required when your app is running a "foreground service"—a Service running in the background that's long living and noticeable to the user, such as a media player. 
This notification cannot be dismissed like other notifications. To remove the notification, the service must be either stopped or removed from the "foreground" state.


	Posting limits
Beginning with Android 8.1 (API level 27), apps cannot make a notification sound more than once per second. If your app posts multiple notifications in one second, they all appear as 
expected, but only the first notification per second makes a sound.



	Notification compatibility :--------------------------------
Since Android 1.0, the notification system UI and the notification-related APIs have continually evolved. To use the latest notification API features while still supporting older devices,
 use the support library notification API: NotificationCompat and its subclasses, as well as NotificationManagerCompat. This will allow you to avoid writing conditional code to check API 
levels because these APIs handle that for you.

NotificationCompat is updated as the platform evolves to include the latest methods. It is important to note that the availability of a method in NotificationCompat does not guarantee that 
the corresponding feature will be provided on older devices. In some cases calling a newly-introduced API results in a no-op on older devices. For example,
 NotificationCompat.addAction() displays the action button on a device running Android 4.1 (API level 16) and higher only.



Create Basic Notification :------------------------
 1) Set the notification content 
To get started you need to set the notification's content and channel using  ( NotificationCompat.Builder   Builder class for NotificationCompat objects. Allows easier control over all the 
flags, as well as help constructing the typical notification layouts.) object
The following example shows how to create a notification with the following:

A small icon, set by setSmallIcon(). This is the only user-visible content that's required.
A title, set by setContentTitle().
The body text, set by setContentText().
The notification priority, set by setPriority(). The priority determines how intrusive the notification should be on Android 7.1 and lower. 
(For Android 8.0 and higher, you must instead set the channel importance—shown in the next section.)


NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Much longer text that cannot fit one line...")
        .setStyle(new NotificationCompat.BigTextStyle()
                .bigText("Much longer text that cannot fit one line..."))
        .setPriority(NotificationCompat.PRIORITY_DEFAULT);


3) Show the notification
To make the notification appear, call NotificationManagerCompat.notify(), passing it a unique ID for the notification and the result of NotificationCompat.Builder.build(). For example:

NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);

// notificationId is a unique int for each notification that you must define
notificationManager.notify(notificationId, builder.build());


5) Add action buttons
A notification can offer up to three action buttons that allow the user to respond quickly, such as snooze a reminder or even reply to a text message. 
But these action buttons should not duplicate the action performed when the user taps the notification.

To add an action button, pass a PendingIntent to the addAction() method. This is just like setting up the notification's default tap action, except instead of launching an activity, 
you can do a variety of other things such as start a BroadcastReceiver that performs a job in the background so the action does not interrupt the app that's already open.





2) Set the notification's tap action
Every notification should respond to a tap, usually to open an activity in your app that corresponds to the notification. To do so, you must specify a content intent defined with a 
PendingIntent object and pass it to setContentIntent().

Intent intent = new Intent(this, AlertDetails.class);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        // Set the intent that will fire when the user taps the notification
        .setContentIntent(pendingIntent)
        .setAutoCancel(true);



	Drawable resource :---------------
A drawablw resource is a general concept for a graphics that can be drawn to the screen and which you can reterieve with APIs such as getDrawable(int) or apply to another Xml resource 
attributes such as android:drawable and android:icon

Different types of Drawable :-

1) Bitmap		:- a bitmap graphics file (.png, .jgp, or .gif) create a BitmapDrawable
2) Nine-patch File	:- A PNG file with stretchable region to allow image resizing on content
3) Layer List	:- A drawable that manage an array of other Drawables .these are drawn in array order so the element with the largest index is be drawn on top.
4) State List	:- an Xml file that reference different bitmap graphics for different states (for example to use a different image when a button is pressed)
5) Level List	:- an Xml file that defines a drawable that manges a number of alternative Drawable each assign a maximum numerical value.
6) Transition Drawable :-  an xml file that define a drawable that can cross fade between two drawable resource.
7) Inset Drawable	:- an sml file that define drawable that insets another drawable by a specific distane.
8)clip drawable	:- an xml file that define a drawable that clip another drawabable
9) Scale Drawable	:- an xml file that define a drawable that change the size of another drawable


A bitmap file is a .png, .jpg, or .gif file. Android creates a Drawable resource for any of these files when you save them in the res/drawable/ directory.

resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename