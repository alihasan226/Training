App Manifest Overview :---------------------------
Every app project must have an AndroidManifest.xml file(with precisely that name) at the root of the project source set.The Manifest declare the essential information about your app to the
Android build tools Android operating system and Google play.


Among many other things the manifest file is required to declare the following: -----------

1) The app's package name which usually matches your code's namespace. The Android build tools use this to determine the location of code entitied when building your project.
When packaging the app the build toolls replace this value with the application ID from the Gradle build files, which is used as the unique app identifier on the system and on Google play.

xmlns:android
Defines the Android namespace . This attributes ahould always be set to  "http://schemas.android.com/spk/res/android".
xmlns:android is for identification that this xml is used for android not for other function.
Namespaces uniquely identify code/libraries if i write an api that uses all the same names and such as the android api the only way to distinguish between my api and android api to use the
android namespace or mine.

2) The components of the app, which include all activities, services, broadcast receivers, and content providers. Each component must define basic properties such as the name of its
Kotlin or Java class. It can also declare capabilities such as which device configurations it can handle, and intent filters that describe how the component can be started

3) The permissions that the app needs in order to access protected parts of the system or other apps. It also declares any permissions that other apps must have if they want to access
 content from this app.

4) The hardware and software features the app requires which affects which devices can install the app from Google play.


File Featues :---------------
The manifest file's root element requires an attribute for your app's package name
For example the following snippet shows the root <manifest> element with the package name "com.example.myapp"
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp"
    android:versionCode="1"
    android:versionName="1.0" >
    ...
</manifest>


while building your app into final application package (APK) the android build use the package attribute for two things :

1) It applies this name as the namespace for your app's generated R.java class (used to access your app resource)
Example with the above manifest the R class is created at com.example.myapp.R

2) It uses this name to resolve any relative class name that are declared in the manifest file
Example : with the above manifest an activity declared as <activity android:name=".MainActivity"> is resolved to be com.example.myapp.MainActivity.

App Components :---------------
For each app component that you create in your app you must declare a corresponding XML element in ht emanifest file:

<activity> for each subclass of Activity
<service> for each subclass of serivce
<receiver> for each subclass of service
<provider> for each subcalss of Content provider


If you subclass any of these component without declaring it in the manifest file the system cannot start it.
The name of your subclass must be specified with the name attribute, using the full package designation. For example, an Activity subclass can be declared as follows:

<manifest ... >
    <application ... >
        <activity android:name="com.example.myapp.MainActivity" ... >
        </activity>
    </application>
</manifest>


However, if the first character in the name value is a period, the app's package name (from the <manifest> element's package attribute) is prefixed to the name. 
For example, the following activity name is resolved to `"com.example.myapp.MainActivity"`:

<manifest package="com.example.myapp" ... >
    <application ... >
        <activity android:name=".MainActivity" ... >
            ...
        </activity>
    </application>
</manifest>

If you have app components that reside in sub-packages (such as in com.example.myapp.purchases), the name value must add the missing sub-package names 
(such as ".purchases.PayActivity") or use the fully-qualified package name.


Intent filters
App activities, services, and broadcast receivers are activated by intents. An intent is a message defined by an Intent object that describes an action to perform, 
including the data to be acted upon, the category of component that should perform the action, and other instructions.

An app component can have any number of intent filters (defined with the <intent-filter> element), each one describing a different capability of that component.


=> Icons and labels
A number of manifest elements have icon and label attributes for displaying a small icon and a text label, respectively, to users for the corresponding app component.

In every case, the icon and label that are set in a parent element become the default icon and label value for all child elements.
 For example, the icon and label that are set in the <application> element are the default icon and label for each of the app's components (such as all activities).



=> Permissions
Android apps must request permission to access sensitive user data (such as contacts and SMS) or certain system features (such as the camera and internet access). 
Each permission is identified by a unique label. For example, an app that needs to send SMS messages must have the following line in the manifest:

<manifest ... >
    <uses-permission android:name="android.permission.SEND_SMS"/>
    ...
</manifest>

Beginning with Android 6.0 (API level 23), the user can approve or reject some app permisions at runtime. But no matter which Android version your app supports,
you must declare all permission requests with a <uses-permission> element in the manifest. If the permission is granted, the app is able to use the protected features.
If not, its attempts to access those features fail


=> Device compatibility
The manifest file is also where you can declare what types of hardware or software features your app requires, and thus, which types of devices your app is compatible with. 
Google Play Store does not allow your app to be installed on devices that don't provide the features or system version that your app requires.

=> <uses-sdk>
Each successive platform version often adds new APIs not available in the previous version. To indicate the minimum version with which your app is compatible,
your manifest must include the <uses-sdk> tag and its minSdkVersion attribute.

However, beware that attributes in the <uses-sdk> element are overridden by corresponding properties in the build.gradle file. So if you're using Android Studio,
you must specify the minSdkVersion and targetSdkVersion values there instead:

android {
  defaultConfig {
    applicationId 'com.example.myapp'

    // Defines the minimum API level required to run the app.
    minSdkVersion 15

    // Specifies the API level used to test the app.
    targetSdkVersion 28

    ...
  }
}

=> <uses-feature>
The <uses-feature> element allows you to declare hardware and software features your app needs. For example, if your app cannot achieve basic functionality on a device
without a compass sensor, you can declare the compass sensor as required with the following manifest tag

<manifest ... >
    <uses-feature android:name="android.hardware.sensor.compass"
                  android:required="true" />
    ...
</manifest>

What is Compass sensor ?
The digital compass that's usually based on a sensor called the magnetometer and provides mobile phones with a simple orientation in relation to the Earth's magnetic field.
 As a result, your phone always knows which way is North so it can auto rotate your digital maps depending on your physical orientation.


=> File Conventions :--------------

1) Elements
Only the <manifest> and <application> elements are required. They each must occur only once. Most of the other elements can occur zero or more times. However, some of them must be
 present to make the manifest file useful.

All of the values are set through attributes, not as character data within an element.

Elements at the same level are generally not ordered. For example, the <activity>, <provider>, and <service> elements can be placed in any order. 
There are two key exceptions to this rule:

An <activity-alias> element must follow the <activity> for which it is an alias.
The <application> element must be the last element inside the <manifest> element.


=> Multiple values
If more than one value can be specified, the element is almost always repeated, rather than multiple values being listed within a single element. For example, an intent filter can list several actions:
<intent-filter ... >
    <action android:name="android.intent.action.EDIT" />
    <action android:name="android.intent.action.INSERT" />
    <action android:name="android.intent.action.DELETE" />
    ...
</intent-filter>






Configure your Build :---------------------





10:52 AM 9/7/2019
	Button Advanceed Operation :-----------------
Performing the Switch operation on button

package com.example.nestedbutton;

import androidx.appcompat.app.AppCompatActivity;
import android.widget.Toast;
import android.widget.Button;
import android.view.View;
import android.os.Bundle;

public class MainActivity extends AppCompatActivity {
    private Button b1,b2;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void clickme(View view)
    {
        switch (view.getId())
        {
            case R.id.button1:
                b1=(Button)findViewById(R.id.button1);
                String button1=b1.getText().toString();
                Toast.makeText(getApplicationContext(),button1,Toast.LENGTH_LONG).show();
                break;
            case R.id.button2:
                b2=(Button)findViewById(R.id.button2);
                String button2=b2.getText().toString();
                Toast.makeText(getApplicationContext(),button2,Toast.LENGTH_LONG).show();
                break;
        }
    }
}


2) Make the Button Stylish :-------




3:03 PM 9/5/2019
Application Fundamentals :------------
Android apps can be written using Kotlin,Java and C++ languages . The Android SDK tools compiles your code along with any data and recources files into an APK, an Android package
which is an archive file with an .apk suffix.
One APK file contains all the content of an ANdroid app and is the file that Android-powered device use to install the app.


The Android system implements the principle of least privilage .That is each app by default has access only to the components that it requires to do its work and no more. This creates a very secure environment only to the components that it requires to do
 its work and  no more. This creates a very secure environment in which an app can't access parts of the system for which it is not given permisson.




	Application Component :-----------------
App components are essentially building blocks of an Android app. Each component is an entry point through which the system or a user can can enter your app. Some component depends on others.
 
there are four different types of app components :-
1) Activities
2) Services
3) Broadcast Receiver
4) Content Provides

Each type serves a distinct purpose and has a distinct lifecycle that defines how the component is created and destroyed

1) Activity
An Activity is the entry point for interacting wiht the user.
It represent a single screen with a user interface.
Example  an email app might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails.


2) Services
A services is a general-purpose entry point for keeping an app running background for all kinds of reasons.
 It is a component that runs in the background to perform long-running operations or to perform work for remote processes. A services does not provide a user interface.
Example a service might play music in the background while the user is in a different app, or it might fetch data over the network without blocking user interaction with an activity.


Bound services run because some other app (or the system) has said that it wants to make use of the service. This is basically the service providing an API to another process.

3) Broadcast Receiver
A broadcast receiver is a component that enables the system to deliver events to the app outside of a regular user flow, allowing the app to respond to system-wide broadcast 
announcements. Because broadcast receivers are another well-defined entry into the app, the system can deliver broadcasts even to apps that aren't currently running.


4) Content Providers
A content provider manages a shared set of app data that you can store in the file system, in a SQLite database, on the web, or on any other persistent storage location that your app can 
access. Through the content provider, other apps can query or modify the data if the content provider allows it. 
For example, the Android system provides a content provider that manages the user's contact information.



	Activating Components :----------------

Three of the four component types --activities , services, and broadcast receivers --are activated by an asynchronous message called an Intent.
Intent bind individual component to each other at runtime. An intent is created with an Intent object, which defines a message to activate either a specific component (explicit intent ) or a 
specific type of component (impicit intent).

For activities and services an intent defines the action to be perform (for example to view  or send something) 










	Broadcast overview :-----------------------

Android apps can send or receive broadcast message from the Android system and other Android apps.
These broadcast are sent when an event of interest occurs. For example the Android system sends broadcast when various system events occurs such as when the system boots up or the 
device stats charging. App can also send custom broadcast, for example to notify other apps of something that they might be interested in(for example some new data has been downloaded).

Apps can register to receive specific broadcasts. When a broadcast is sent, the system automatically routes broadcasts to apps that have subscribed to receive that particular type of 
broadcast.



=> About system broadcasts

The system automatically sends broadcasts when various system events occur, such as when the system switches in and out of airplane mode. System broadcasts are sent to all apps that 
are subscribed to receive the event.

The broadcast message itself is wrapped in an Intent object whose action string identifies the event that occurred (for example android.intent.action.AIRPLANE_MODE). 
The intent may also include additional information bundled into its extra field. For example, the airplane mode intent includes a boolean extra that indicates whether or not Airplane Mode is on.


=> Changes to system broadcasts
As the Android platform evolves, it periodically changes how system broadcasts behave. Keep the following changes in mind if your app targets Android 7.0 (API level 24) or higher, or
 if it's installed on devices running Android 7.0 or higher.

Android 9
Beginning with Android 9 (API level 28), The NETWORK_STATE_CHANGED_ACTION broadcast doesn't receive information about the user's location or personally identifiable data.

In addition, if your app is installed on a device running Android 9 or higher, system broadcasts from Wi-Fi don't contain SSIDs, BSSIDs, connection information, or scan results. 
To get this information, call getConnectionInfo() instead.

Android 8.0
Beginning with Android 8.0 (API level 26), the system imposes additional restrictions on manifest-declared receivers.

If your app targets Android 8.0 or higher, you cannot use the manifest to declare a receiver for most implicit broadcasts (broadcasts that don't target your app specifically). 
You can still use a   {  context-registered receiver   }   when the user is actively using your app.


Android 7.0
Android 7.0 (API level 24) and higher don't send the following system broadcasts:

ACTION_NEW_PICTURE
ACTION_NEW_VIDEO
Also, apps targeting Android 7.0 and higher must register the CONNECTIVITY_ACTION broadcast using registerReceiver(BroadcastReceiver, IntentFilter).
Declaring a receiver in the manifest doesn't work.


=> Context-Register Receiver
To register a receiver with a context perform the follwoing steps:

1) Create an instance of BroadcasarReceiver

	BroadcastReceiver br=new MyBroadcastReceiver();

2) Create an IntentFilter and register the receiver by calling registerReceiver (BoradcastReceiver,IntentFilter):

	IntentFilter filter=new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
	filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
	registerReceiver(br,this);

3) To stop receiving broadcasts, call unregisterReceiver(android.content.BroadcastReceiver). Be sure to unregister the receiver when you no longer need it or the context is no longer 
valid.

Be mindful of where you register and unregister the receiver, for example, if you register a receiver in onCreate(Bundle) using the activity's context, you should unregister it in 
onDestroy() to prevent leaking the receiver out of the activity context. If you register a receiver in onResume(), you should unregister it in onPause() to prevent registering it multiple
times (If you don't want to receive broadcasts when paused, and this can cut down on unnecessary system overhead). Do not unregister in onSaveInstanceState(Bundle), because this
isn't called if the user moves back in the history stack.



Sending Broadcasts :-----------------------
Android provides three ways for app to send broadcast

1) The sendOrderedBroadcast(Intent,String) methods sends broadcast s to one receiver at a time. As each receiver executes it turn it can propagate a result to the receiver or it can 
completelt abort the broadcast so that it won't be passed to other receivers.The order receiver run in can be controlled with the android:parioority attribute of amtching intent-filter receiver with 
the same protity will be run in an arbitrary order.

2) The sendBroadcast(Intent) method sends broadcasts to all receivers in an undefined order. This is called a Normal Broadcast. This is more efficient, but means that receivers cannot 
read results from other receivers, propagate data received from the broadcast, or abort the broadcast.

3)The LocalBroadcastManager.sendBroadcast method sends broadcasts to receivers that are in the same app as the sender. If you don't need to send broadcasts across apps,
use local broadcasts. The implementation is much more efficient (no interprocess communication needed) and you don't need to worry about any security issues related to other apps
being able to receive or send your broadcasts.





The Manifest file :---------------------

Before the Android system can start an app component , start system must know that the component exist by reading the app's manifest file AndroidManifest.xml.
Your app must declare all its component  in this file which must be at the root of the app project directory.

The Manifest does a number of thing in addition to declaring the app's components such as the following:-
=> Identifies any user permission the app requires such  as internet access or read-access to the user's contacts.
=> Declaring the minimum level API Level required by the app based on which APIs the app uses.
=> Declares hardware and software feature sued or required by the app such as a camera, bluetooth service or a multitouch screen.
=> Declares API libraries the app needs to be linked againest 

<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>

In the <application> element, the android:icon attribute points to resources for an icon that identifies the app.

In the <activity> element, the android:name attribute specifies the fully qualified class name of the Activity subclass and the android:label attribute specifies a string to use as the 
user-visible label for the activity.


You must declare all app components using the following elements:

<activity> elements for activities.
<service> elements for services.
<receiver> elements for broadcast receivers.
<provider> elements for content providers.
Activities, services, and content providers that you include in your source but do not declare in the manifest are not visible to the system and, consequently, can never run. 
However, broadcast receivers can be either declared in the manifest or created dynamically in code as BroadcastReceiver objects and registered with the system by calling 
registerReceiver().


Declaring component capabilities :----------------------------

As discussed above, in Activating components, you can use an Intent to start activities, services, and broadcast receivers. You can use an Intent by explicitly naming the target component
(using the component class name) in the intent. You can also use an implicit intent, which describes the type of action to perform and, optionally, the data upon which you’d like to perform 
the action. 

The system identifies the components that can respond to an intent by comparing the intent received to the intent filters provided in the manifest file of other apps on the device.




	App resources Overview :--------------------------------

Resources are the additional files and static content that your code uses such as bitmap, layout definitions, user interfaces string, animation instruction and more.
You should always externalize app resources sich as image and string from your code so that you can maintain them independently. you should also provide alternative resources for specific 
device configurations by grouping them in specially-named resources directories. At runtime android uses the appropriate resource based on the cureent configuration.


	
	BroadCast Receiver ;---------------------------------------

In Android Broadcast Receiver is a component which  will allow android system or other system or other apps to delever events to the app like sending a low battery message or screen turned off
message to the app. The app can also broadcast to let other apps know that required data availabe in a device to use it.

Generally we use Intent to deliver broadcast events to other apps and Boradcast Recciver use status bar notification to let user know that broadcast events occurs.
In android Broadcast Receiver is implementted as a subclass of BroadcastReceiver and each braodcast is delivered as an Intent object.

we can register an app to receive only few broadcast message based on our requirements. When a new broadcasr received the system will check for specifieed have subscribed or not subscribed or not based on that it will routes the broadcast to the apps.

1)

One way is by registring a broadcast using android application manifest file (AndroidManifest.xml) we need to specify <receiver> element in apps manifest file line as shown below.

<receiver android:name=".SampleBroadcastReceiver">

    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED"/>
    </intent-filter>
</receiver>

2)
Suppose if we register for ACTION_BOOT_COMPLETED events whenever the boot process is completed the broadcast receiver's method onReceive() method will be invoked.





	Sending Broadcasts :-----------------------

In android, we can send a broadcasts in apps using three different ways, those are 

Method					Description

sendOrderedBroadcast(Intent, String)		This method is used to send broadcasts to one receiver at a time.
sendBroadcast(Intent)			This method is used to send broadcasts to all receivers in an undefined order.
LoadBroadcastManager.sendBroadcast		This method is used to send broadcasts to receivers that are in the same app as the sender.














	Services :-----------------------------------------------

A services is an application component that can perform long-running operations in the background, and it doesn't provides a user interface.
Another application component can start a service and it continues to run in the background even if the user switches to another application.

Additionally a component can bind to s vervice to interact with in and even perform interprocess communication (IPC)

For example a service can handle network transaction, play music, perform file I/O or interact with a content provider all from the background.



	There are three different types of services:

1) Foreground

A foreground service performs some operations that is noticeable to the user.
For example an audio app would use a foreground service to play an audio track. Foreground service must display a Notification.
Foreground services continue running even when the user isn't interacting with the app.

2) Background 

A background service performs an oparation that isn't directly noticed by the user.
For example if an app used a service its storage that would usually be a background service.

Note: If your app targets API level 26 or higher, the system imposes restrictions on running background services when the app itself isn't in the foreground. In most cases like this, 
your app should use a scheduled job instead


3) Bound
A service is bound when an application compoennt binds to it by calling bindService().
A bound service offeres a client-server interface that allows components to interact with the service, send request, receive result and even do so across processes with interprocess communication (IPC).
A bound service runs only as long as another application component is bound to it. Multiple components can bind to the service at once but when all of them unbind, the service is destroyed.



Although this documentation generally discusses started and bound services separately, your service can work both ways—it can be started (to run indefinitely) and also allow binding. 
It's simply a matter of whether you implement a couple of callback methods: onStartCommand() to allow components to start it and onBind() to allow binding.


=> Choosing between a service and a thread :--
A service is simply a component that can run in the background even when the user is not interacting with your application so you should create a service only if that is what you need.

if you must perform work outside of your main thread but only while the user is interacting with your application youshould create  anew thread. 
For example if you want to play some music but only while your activity is running you might create a thread in onCreate(), start running it in onStart() and onStop() and stop it in on Stop().
Also consider using AsyncTask or Handlerthread instead of the traditional Thread class.





	The basic :--------------------
To create a service you must create a subclass of service or use one of its existing subclasses.
In your implemnetation you must override some callback methods that handle aspect of the service lifecycle and provide a mechanism that allows the component to bind to the service.

=> onStartCommand()

The system invokes this method by calling startService() when another component (such as an activity) requests that the service be started. When this method executes, the service
is started and can run in the background indefinitely. If you implement this, it is your responsibility to stop the service when its work is complete by calling stopSelf() or stopService(). 
If you only want to provide binding, you don't need to implement this method.

=> onBind()

The system invokes this method by calling bindService() when another component wants to bind with the service (such as to perform RPC). In your implementation of this method,
you must provide an interface that clients use to communicate with the service by returning an IBinder. You must always implement this method; however, if you don't want to allow 
binding, you should return null


=> onCreate()
The system invokes this method to perform one-time setup procedures when the service is initially created (before it calls either onStartCommand() or onBind()).
If the service is already running, this method is not called.

=> onDestroy()
The system invokes this method when the service is no longer used and is being destroyed. Your service should implement this to clean up any resources such as threads, registered 
listeners, or receivers. This is the last call that the service receives.

If a component starts the service by calling startService() (which results in a call to onStartCommand()), the service continues to run until it stops itself with stopSelf() or another 
component stops it by calling stopService()

If a component calls bindService() to create the service and onStartCommand() is not called, the service runs only as long as the component is bound to it. After the service is 
unbound from all of its clients, the system destroys it.



=> Declaring a service in the manifest
you must declare all service in your application's manifest file just as you do for activities and other components.
To declare your service add a <service> element as a child of the <application> element.

<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>



There are other attributes that you can include in the <service> element to define properties such as the permissions that are required to start the service and the process in which 
the service should run.

android:name attribute is the only required attribute --it specifies the class name of the service. After you publish your application leave this name unchanged to avoid the risk of breaking 
code due to dependence on explicit intents to start or bind the service.




Notice that the onStartCommand() methods must return an Integer. The integer is a value that describe how the system should continue the service in hte event that the system kills it.The default
implementation for IntentService handles this for you but you are able to modify it. The return value from onStartCommand() must be one of the following constants:

1)START_NOT_STICKY
If the system kills the service after onStartCommand() return do not recreate the service unless there are pending intents to deliver.This is safest option to avoid running service when 
not necessary and when your application can simply restart any unfinished jobs.

2) START_STICKY
if the system kills the service after onStartCommand() returns recreate the service and call onStartCommand() but do not redliver the last intent.In that case those intents are delivered.This 
is suitable for media players (or similar service) that are not executing commands but are running indefinitely and waiting for a job.


3) START_REDELIVER_INTENT
if the system kills the service after onStartCommand() return recreate the service and call onStartCommand() with the last intent that was deliverd to the service.
Any pending intents are delivered in turn. This is suitable for services that are actively performing a job that should be immediately resumed such as download a file.



Starting a Services :-----------------------------
you can start a service from an activity or other application component by passing an Intent to startService() or startForegroundService().
The Android system calls the service's onStartCommadn() methods and pass it the Intent which specifies which service to start.


Note: If your app targets API level 26 or higher, the system imposes restrictions on using or creating background services unless the app itself is in the foreground. If an app needs to 
create a foreground service, the app should call startForegroundService(). That method creates a background service, but the method signals to the system that the service will promote 
itself to the foreground. Once the service has been created, the service must call its startForeground() method within five seconds.

For example an activity can start the example service in the previous section (helloService) using an Explicit intent with startService()

Intent intent=new Intent(this,HelloService.class);
startService(intent);

The startService() method returns immediately and the Android system calls the service's onStartCommand() method if the service isn't already running the system first calls onCreate()
and then it calls onStartCommand().

If the service doesn't also provide binding, the intent that is delivered with startService() is the only mode of communication between the application component and the service.
However, if you want the service to send a result back, the client that starts the service can create a PendingIntent for a broadcast (with getBroadcast()) and deliver it to the service in the Intent that starts the service. The service can then use the broadcast to deliver a result.

Multiple requests to start the service result in multiple corresponding calls to the service's onStartCommand(). However, only one request to stop the service 
(with stopSelf() or stopService()) is required to stop it






=> Sending notification to the user :---------------------------
When a service is running it can notify the user of events using ToastNotification or Status bar notificatios.

A Toast Notification is a message that appears on the surface of the surrent windows fo ronly a moment before disappearing.
A status bar notification provides an icon in the status bar with a message which the user can select in order to make an action (such as start an activity)

Usually a status bar Notification is best technique to use when background works such as a file download has completed, and the user cannow act on it.
When the user select the notification from the expanded view the notification can start an activity (such as to display to downloaded file)



=>Running a service in the Foreground :---------------------
A foreground service is a service that the user is actively aware of and  isn't a candidate fro the system to kill when low on memory.
Foreground service must provides a notification for the status bar which in placed under ongoing heading .
This meas that the notification cannot be dismissed unless the service is either stopped or removed from the foreground.


For Example,  a music player that plays music from a service should be set to run in the foreground, because the user is explicitly aware of its operation.
 The notification in the status bar might indicate the current song and allow the user to launch an activity to  interact with the music player. Similarly, an app to let users track their runs 
would need a foreground service to track the user's location.

To request that your service run in the foreground, call startForeground(). This method takes two parameters: an integer that uniquely identifies the notification and the 
Notification for the status bar. The notification must have a priority of PRIORITY_LOW or higher. 


Intent notificationIntent = new Intent(this,ExampleActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(this,0,notificationIntent,0);

Notification notification = new Notification.Builder (this,CHANNEL_DEFAULT_IMPORTANCE)
	..setContentTitle(getText(R.string.notification_title))
    	.setContentText(getText(R.string.notification_message))
    	.setSmallIcon(R.drawable.icon)
    	.setContentIntent(pendingIntent)
    	.setTicker(getText(R.string.ticker_text))
    	.build();

startForeground(ONGOING_NOTIFICATION_ID, notification);


To remove the service from the foreground, call stopForeground(). This method takes a boolean, which indicates whether to remove the status bar notification as well. 
This method does not stop the service. However, if you stop the service while it's still running in the foreground, the notification is also removed.




10:31 AM 9/3/2019


	Intent :------------

public class Intent extends Object implements Parcelable, Cloneable

Parcelable => Interface for classes whose instance can be written to and restored from a Parcel. Classes implementing the Parcelable interface must also have a non-null static field caled 
	       CREATOR of a type that implements the Parcelable.Creator interface
Parcel	 => Container for a message (data and object references) that can be sent through an IBinder.

Cloneable => A class implements the Cloneable interface to indicate to the Object.clone() method that it is legal for that method to make a field-for-field copy of instance of that class.
		creates and returns a copy of this object.


An Intent is an abstract description of an operation to be performed. It can be used with
Intents are asynchronus message which allow Android component to request functionality from other component of the Android System.

startActivity(Intent) 	=> to launched an Activity
broadcastIntent	=> to send it to any interested  BroadcastReceiver components
startService(Intent)	/ bindService(Intent, ServiceConnection, int)	=> to communicate with background.

Intent has been used to call another acitivity
Its most significant use  is in the launching of activites, where it can be throught of as the glue between activites.
It is basically a passive data structure holding an abstract description of an action to be performed.



Intent Structure :--------------
The primary pieces of information in an intent are :

1) Action	:- the general action to be performed such as  ACTION_VIEW,  ACTION_EDIT,  ACTION_MAIN

2) Data	:- the data to operate on such as a person records in the contact database, expressed as a Uri.

Some of the Example of action/data pair are: --------

1) ACTION_VIEW content://contacts/people1 => display information about the person whose identifier is 1
2) ACTION_DIAL tel:123	=> display the phone dialer with the given number filled in 


Inaddition to these primary attributes there are number of secondary attribute that you can also include with an intent:-

3) Category	:- gives additional information about the action to execute. For example CATEGORY_LAUNCHER means it should appear in the Launcher as a top-level application.

4) Type		:- specifies an explicity type (a MIME type) of the intent data

5) Component	:- specifies an explicit name of a component class to use for the intent >Normally this is determined by looking at the other information in the intent (action, data/type and categories)
		and matching that with a component that can handle

6) Extras		:- this is a Bundle of any additional information.this can be used to provide extended information to the component.
		For example if we have a action to send an e-mail message we could include extra pieces of data here to supply a subject body etc.


In Android the reuse of other application components is a concept knowns as task. An application can access other Android components to achieve a task.
For Example from a component of your application you can trigger another component in the Android system which manage photos, even it thif component is not part of your application. 
In this component you select a photo and return to your application to use the selected photo.


 => Here are some examples of other operations you can specify as intents using these additional parameters:

ACTION_MAIN with category CATEGORY_HOME -- Launch the home screen.

ACTION_GET_CONTENT with MIME type vnd.android.cursor.item/phone -- Display the list of people's phone numbers, allowing the user to browse through them and pick one and return it to the parent activity.





Intent  Resolution :---------------
There are two primary forms of intens you will use

1) Explicit Intent
2) Implicit Intent


Explicit Intent :-----------
In Android Explicit Intent explicitly specify the name of component to be invoked by an activity and we use explicit intents to start a component in out own app.
By using explicit intents we can send or share data / content from one activity to another activity based on your requirement
Explicit intent going to be connected internal world of application suppose if you wants to connect one activity to another activity we can do this quoteby explicit intent.
To create an Explicit Intent we need to define the component name for Intent object.

It have specifies a component (via setComponent(CompoenntName) or setClass(Context,Class)),which provides the exact class to be run.Often these will not include any other information
simply beign a way fro an application to launch various internal acitvities it has as the user interact with the application.


Example :------------------------------
package com.example.explicitintent;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;

public class MainActivity extends AppCompatActivity {
    protected EditText firstnumber,secondnumber;
    protected Button sum;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        firstnumber=(EditText)findViewById(R.id.editText);
        secondnumber=(EditText)findViewById(R.id.editText2);
        sum=(Button)findViewById(R.id.button2);

        sum.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                int number1=Integer.parseInt(firstnumber.getText().toString());
                int number2=Integer.parseInt(secondnumber.getText().toString());
                int sum=number1+number2;
                Intent intent=new Intent(getApplicationContext(),ResultActivity.class);      //the intent is sending to other activity that is ResultActivity.java
                intent.putExtra("SUM"," "+sum);
                /*
                putExtra() adds extended data to the intent which of
                two parameter( name of extra data ) second parameter is( data )itself


                it is get called by getExtra() by the name that was specified
                 */
                startActivity(intent);						/// this ise used for starting the activity
            }
        });
    }
}


Now we are gonna register that activity in the AndroidManifest.xml file in <activity> tag

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.explicitintent">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity android:name=".ResultActivity" ></activity>			//here we declare the other activity class to which we are gonna interact after perform some event.

    </application>

</manifest>


//Now we have the another class that is resultactivity.java that is gonna be called after expliclit intent called.
{
    private ActionBar actionBar;
    @Override
    protected void onCreate(Bundle saveInstanceState) {

        super.onCreate(saveInstanceState);
        setContentView(R.layout.result);
        actionBar=getSupportActionBar();
        actionBar.setTitle("Explicit Intent - Activity2");
        TextView result=(TextView)findViewById(R.id.result_view);
        Intent intent=getIntent();
        String addition=(String)intent.getSerializableExtra("SUM");
        /*
        getExtra() fetches data which was added using putExtra()
         */
        addition="Sum = "+addition;
        result.setText(addition);
    }
}


//it will have the separeate layoutxml file  to show the UI.


=> getExtras()

public Bundla getExtras()
Reterieve a map of extended data from the intent

Returns
Bundle 		=> the map of all extras previously added with putExtra() or null if none been added.




Implicit Intent :-----------
These intent do not name a target and the field of the component name is left blank. Implicit intents are often used to activate component in other application.
It is not specified a component instead they must include enough information for the system to determine which of the available component is best to run for that intent.

When using implicit intent given such an arbitaray intent we need to know what to do with it.This is handle by the process of intent resolution which maps an intent to an Activity
BroadCastreceiver or Service 

		The intent resolution mechanism basically revolve around matching an intnet against all of <intent-filter> descriptions in the installation package.

There are three pieces of information in the intent that are used for resolution: the action , type , and category

Intent-filter :------------------
Intent Filter is an expression in app's manifest file (ActivityManifest.xml) and it is used to specify the type of intent that the component would like to receive. In case if we create Intent filter 
for an activity there is a possibility for other apps to start our activity by sending a certain type of intent.
											otherwise the activity can be started only by an explicit intent.




There are three intent characteristics you can filter on the action , data and categories. 
For each of these characteriscs you can provides multiple possible matching values (via addAction(String),
 addDataType(String), addDataScheme(String), addDataSchemeSpecificpart(String ,int), addDataAuthority(String,String), addDataPath(String,int) and addCategory(String), respectively)


Filter Rule :-----------

A match is based on the following rule.Note that for an IntentFilter to match an Intent three condition must hold the action and category must match and the data (both data type and data 
scheme+authority+path if specified) must match

=> Action matches if any of the given values match the Intent action; if the filter specifies no actions, then it will only match Intents that do not contain an action.

=> Data Type matches if any of the given values match the Intent type. The Intent type is determined by calling Intent#resolveType. A wildcard can be used for the MIME sub-type, in both 
the Intent and IntentFilter, so that the type "audio/*" will match "audio/mpeg", "audio/aiff", "audio/*", etc. Note that MIME type matching here is case sensitive, unlike formal RFC MIME
types! You should thus always use lower case letters for your MIME types.

=> Data Scheme matches if any of the given values match the Intent data's scheme. The Intent scheme is determined by calling Intent#getData and Uri.getScheme() on that URI.
Note that scheme matching here is case sensitive, unlike formal RFC schemes! You should thus always use lower case letters for your schemes.

=> Data Scheme matches if any of the given values match the Intent data's scheme. The Intent scheme is determined by calling Intent#getData and Uri.getScheme() on that URI.
 Note that scheme matching here is case sensitive, unlike formal RFC schemes! You should thus always use lower case letters for your schemes.




Adds a data specificatio to an intent filter. The specification can be just a data type (the mime Type attribute),just a URI , or both a data types and a URI. A URI is specified by separated attributes
for each of its parts :-
These attribute that specifiy the URL fromat are optional but also mutually dependent
=> If a scheme is not specifies for the intent filter all the other URI attribute are ignored.
=> If a host is not specified for the filter the port attribute and all the path attributed are ignored.

setData() method specifies data ony as a URI
setType() specifies it only as a MIME type
setData and setType() specifies it as both a URI and a MIME type.
The URI is read by getData() 
The type is read by getType()




Generally the Intent Filter ( <intent-filter> ) whatever we define in manifest file can be nested in the corresponding app components and we can specify the type of intent to accept using these
three elements.

<Action>It define the name of an intent action to be accepted and it must be a literal string value of an action not the class contant.

<categories> it define the name of an intent category to be accepted and it must be the literal string value of an action not the class constant.

<data>
It defines the type of data to be accepted and by using one or more attributes we can specify various aspects of the data URI (scheme, host, port, path) and MIME type


Intent Filter in Manifest File 
Following is the code snippet of defining an activity with Intent Filter (<intent-filter>) in Android Manifest file (AndroidManifest.xml) like as shown below.

 

<activity android:name=".MainActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
        <data android:mimeType="text/plain"/>
    </intent-filter>
</activity>

We can define a filter with multiple instances of <action>, <category> or <data> elements and we need to make sure that component can handle all the combinations of filter elements.






3:02 PM 9/10/2019

Fragments :---------------------------------------------
A Fragment is a piece of an activty which enable more modular activity design.It will not ne wrong if we say a fragment is a kind of sub activity.

Following are important points about fragment :--------------------------

A fragment has its own layout and its own behaviour with its own life cycle callbacks.

You can add or remove fragments in an activity while the activity is running.

You can combine multiple fragments in a single activity to build a multi-pane UI.

A fragment can be used in multiple activities.

Fragment life cycle is closely related to the life cycle of its host activity which means when the activity is paused, all the fragments available in the activity will also be stopped.

A fragment can implement a behaviour that has no user interface component.

Fragments were added to the Android API in Honeycomb version of Android which API version 11


=> You create fragments by extending Fragment class and You can insert a fragment into your activity layout by declaring the fragment in the activity's layout file, as a <fragment> element



Fragment life-cycle :-----------------

1) onAttach()
 the fragment instance is associate with an activity instance. The fragment and the activity is not fully initialized.Typically you get in this method a reference to the activity
which uses the fragemnt for furthrt initialization work.

2) onCreate()
call this method when fragment is created

3) onCreateView()
call this method when fragment draw user interface for the first time. To draw a UI for your fragment you must return a view component from this method that is the root of fragment layout.

4) onActivityCreated()
The onActivityCreated() is called after onCreateView() method when the host activity is created.At this point view can be accessed with the findViewBy Id() method...

5) onStart()
this method is called once the fragemnt gets visible

6) onResume() fragment become active

7) onPause()
user in leaving the fragment

8) onStop() 
fragment is going to stop by calling onStop()

9) onDestroyView()
Fragment view will destroy after call this method

10) onDestroy
this is called to do final clean up.


How to use Fragments?
This involves number of simple steps to create Fragments.

First of all decide how many fragments you want to use in an activity. For example let's we want to use two fragments to handle landscape and portrait modes of the device.

Next based on number of fragments, create classes which will extend the Fragment class. The Fragment class has above mentioned callback functions. You can override any of the functions based on your requirements.

Corresponding to each fragment, you will need to create layout files in XML file. These files will have layout for the defined fragments.

Finally modify activity file to define the actual logic of replacing fragments based on your requirement.




public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }
}


The container parameter passed to onCreateView() is the parent ViewGroup in which your fragment layout in inserted.

The saveInstanceState parameter is a Bundle that provides data about the previous instance of the fragment if the fragment is being resumed.



inflate() method takes three arguments:

1) resource ID of the layout you want to inflate
2) ViewGroup to be the parent of the infalted layout.Passing the container is important in order for the system to apply layout parameter to root view of the infalted specified by the parent view 
in which it's going.
3) boolean indicating whether the inflate layout should be attached to the ViewGroup.

Adding a user interface :------------------------------
A fragment is usually used as part of an acitvity user interface and contributes its own layout to the activity.
To provide a layout from fragment you must implement the onCreateView() callback mwthod which must return a View that is the root of your fragmen' name.



Types of Fragments :----------------------

Basically fragments are divided as three stages as shown below.

1) Single frame fragments - Single frame fragments are using for hand hold devices like mobiles, here we can show only one fragment as a view.

2) List fragments - fragments having special list view is called as list fragment

3) Fragments transaction - Using with fragment transaction. we can move one fragment to another fragment




Adding a fragment to an Activity :------------------------
Usually a fragment contribute a portion of UI to the host activity which is embedded as a part of the activity's overall view hierarchy. There are two ways you can add a fragment to the 
activity layout:-------------------


1) Declare the fragment inside the activity's layout file

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
    <fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
</LinearLayout>

The android:name attribute in the <fragment> specifies the Fragment class to instantiate in the layout.


summary:--------------------------
we can add fragment by using the <fragment> tag that will be in the activity_main.xml file with a name of the  sub class that we declare in the MainActivity.java directory.






2) Programmatically add the fragment to an existing ViewGroup.
At any time while your activity is running you can add fragment to your activity layouot. you simply need to specify a ViewGroup in which to place the fragment.


To make fragment transactions in your activity (such as add, remove, or replace a fragment), you must use APIs from FragmentTransaction. 
You can get an instance of FragmentTransaction from your FragmentActivity like this:

FragmentManager fragmentManager = getSupportFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

You can then add a fragment using the add() method,


ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();

The first argument passed to add() is the ViewGroup in which the fragment should be placed specified by resource ID, and  the second parameter fragment to add.

Once you've made your changes with FragmentTransaction you must call commit() for the changes to take effect.



=> Managing Fragments

To manage the fragments in your activity, you need to use FragmentManager. To get it, call getSupportFragmentManager() from your activity.
Some things that you can do with FragmentManager include:

1) Get fragments that exist in the activity, with findFragmentById() (for fragments that provide a UI in the activity layout) or findFragmentByTag() (for fragments that do or don't provide a UI).
2) Pop fragments off the back stack, with popBackStack() (simulating a Back command by the user).
2) Register a listener for changes to the back stack, with addOnBackStackChangedListener().

For more information about these methods and others, refer to the FragmentManager class documentation.

As demonstrated in the previous section, you can also use FragmentManager to open a FragmentTransaction, which allows you to perform transactions,
such as add and remove fragments.


Before you call commit(), however, you might want to call addToBackStack(), in order to add the transaction to a back stack of fragment transactions. \
This back stack is managed by the activity and allows the user to return to the previous fragment state, by pressing the Back button


In this example, newFragment replaces whatever fragment (if any) is currently in the layout container identified by the R.id.fragment_container ID. By calling addToBackStack(), the replace transaction is saved to the back stack so the user can reverse the transaction and bring back the previous fragment by pressing the Back button.

FragmentActivity then automatically retrieve fragments from the back stack via onBackPressed()












10:11 AM 9/4/2019

Notification :--------------------------------------------------

A notification is a message that android display outside your app's UI to provide the user with remainders communication from other people or other timely information from your app.


Appearance on a Device :----------------------

 Notification appear to user in different locations and formats such as an icon in the status bar a more detailed entry in the notification drawer as a badge on the app's icon and on paired wearable automatically.

1) Staus bar notification drawer
When you issue a notification, it first appears as an icon in the status bar.
Users can swipe down on the status bar to open the notification drawer, where they can view more details and take actions with the notification.


2) Heads-up notification
Beginning with Android 5.0, notifications can briefly appear in a floating window called a heads-up notification. This behavior is normally for important notifications that the user should 
know about immediately, and it appears only if the device is unlocked.

The heads-up notification appears the moment your app issues the notification and it disappears after a moment, but remains visible in the notification drawer as usual.

Example conditions that might trigger heads-up notifications include the following:

The user's activity is in fullscreen mode (the app uses fullScreenIntent).
The notification has high priority and uses ringtones or vibrations on devices running Android 7.1 (API level 25) and lower.
The notification channel has high importance on devices running Android 8.0 (API level 26) and higher.


4) Lock screen

Beginning with Android 5.0, notifications can appear on the lock screen.
You can programmatically set the ( level of detail visible ) in notifications posted by your app on a secure lock screen, or even whether the notification will show on the lock screen at all.
Users can use the system settings to choose the level of details visible in lock screen notifications, including the option to disable all lock screen notifications. Starting with Android 8.0, 
users can choose to disable or enable lock screen notifications for each notification channel.

5) App icon badge
In supported launchers on devices running Android 8.0 (API level 26) and higher, app icons indicate new notifications with a colored "badge" (also known as a "notification dot") 
on the corresponding app launcher icon.

Users can long-press on an app icon to see the notifications for that app. Users can then dismiss or act on notifications from that menu, similar to the notification drawer.


6) Wear OS devices
If the user has a paired Wear OS device, all your notifications appear there automatically, including expandable detail and action buttons.

You can also enhance the experience by customizing some appearances for the notification on wearables and provide different actions, including suggested replies and voice input 
replies. For more information, see how to add wearable-specific features to your notification.


Notification anatomy :-------------------

The design of a notification is determined by system templates—your app simply defines the contents for each portion of the template.


Notification actions
Although it's not required, every notification should open an appropriate app activity when tapped. In addition to this default notification action, you can add action buttons that complete
 an app-related task from the notification (often without opening an activity)

Expandable notification
By default, the notification's text content is truncated to fit on one line. If you want your notification to be longer, you can enable a larger text area that's expandable by applying an 
additional template


	Notification updates and groups :----------------------

To avoid bombarding your users with multiple or redundant notifications when you have additional updates, you should consider updating an existing notification rather than issuing a 
new one, or consider using the inbox-style notification to show conversation updates.

However, if it's necessary to deliver multiple notifications, you should consider grouping those separate notifications into a group (available on Android 7.0 and higher). 
A notification group allows you to collapse multiple notifications into just one post in the notification drawer, with a summary. The user can then expand the notification to 
reveal the details for each individual notification.



	Notification channels :------------------

Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel or it will not appear. By categorizing notifications into channels, users can disable specific notification 
channels for your app (instead of disabling all your notifications), and users can control the visual and auditory options for each channel—all from the Android system settings (figure 11).



	Notification importance :-------------------

Android uses the importance of a notification to determine how much the notification should interrupt the user (visually and audibly). The higher the importance of a notification, 
the more interruptive the notification will be.

On Android 8.0 (API level 26) and above, importance of a notification is determined by the importance of the channel the notification was posted to. Users can change the importance
 of a notification channel in the system settings (figure 12). On Android 7.1 (API level 25) and below, importance of each notification is determined by the notification's priority.



The possible importance levels are the following:

Urgent: Makes a sound and appears as a heads-up notification.
High: Makes a sound.
Medium: No sound.
Low: No sound and does not appear in the status bar.



	Do Not Disturb mode ;---------------

Starting in Android 5.0 (API level 21), users can enable Do Not Disturb mode, which silences sounds and vibration for all notifications. Notifications still appear in the system UI as
 normal, unless the user specifies otherwise.

There are three different levels available in Do Not Disturb mode:

Total silence: blocks all sounds and vibrations, including from alarms, music, videos, and games.
Alarms only: blocks all sounds and vibrations, except from alarms.
Priority only: users can configure which system-wide categories can interrupt them (such as only alarms, reminders, events, calls, or messages). For messages and calls, users can also 
choose to filter based on who the sender or caller is



Notifications for foreground services (Some Doubt)

A notification is required when your app is running a "foreground service"—a Service running in the background that's long living and noticeable to the user, such as a media player. 
This notification cannot be dismissed like other notifications. To remove the notification, the service must be either stopped or removed from the "foreground" state.


	Posting limits :---------------

Beginning with Android 8.1 (API level 27), apps cannot make a notification sound more than once per second. If your app posts multiple notifications in one second, they all appear as 
expected, but only the first notification per second makes a sound.



	Notification compatibility :--------------------------------

Since Android 1.0, the notification system UI and the notification-related APIs have continually evolved. To use the latest notification API features while still supporting older devices,
 use the support library notification API: NotificationCompat and its subclasses, as well as NotificationManagerCompat. This will allow you to avoid writing conditional code to check API 
levels because these APIs handle that for you.

NotificationCompat is updated as the platform evolves to include the latest methods. It is important to note that the availability of a method in NotificationCompat does not guarantee that 
the corresponding feature will be provided on older devices. In some cases calling a newly-introduced API results in a no-op on older devices. For example,
NotificationCompat.addAction() displays the action button on a device running Android 4.1 (API level 16) and higher only.




Create Basic Notification :------------------------

1) Set the notification content 

To get started you need to set the notification's content and channel using  ( NotificationCompat.Builder   Builder class for NotificationCompat objects. Allows easier control over all the 
flags, as well as help constructing the typical notification layouts.) object
The following example shows how to create a notification with the following:

A small icon, set by setSmallIcon(). This is the only user-visible content that's required.
A title, set by setContentTitle().
The body text, set by setContentText().
The notification priority, set by setPriority(). The priority determines how intrusive (Intruptive) the notification should be on Android 7.1 and lower. 
(For Android 8.0 and higher, you must instead set the channel importance—shown in the next section.)


NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)	//single interface for creating notification and let support library do all compatibility
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Much longer text that cannot fit one line...")
        .setStyle(new NotificationCompat.BigTextStyle()
                .bigText("Much longer text that cannot fit one line..."))
        .setPriority(NotificationCompat.PRIORITY_DEFAULT);


3) Show the notification

To make the notification appear, call NotificationManagerCompat.notify(), passing it a unique ID for the notification and the result of NotificationCompat.Builder.build(). For example:

NotificationManagerCompat  notificationManager = NotificationManagerCompat.from(this);

// notificationId is a unique int for each notification that you must define
notificationManager.notify(notificationId, builder.build());



//Updating Single Notification 
to update notification (that is already showing active) one just should just send new notification with the same.id Old notification will be replaced with new one.

2) Set the notification's tap action
Every notification should respond to a tap, usually to open an activity in your app that corresponds to the notification. To do so, you must specify a content intent defined with a 
PendingIntent object and pass it to setContentIntent().
for Handling clicking on notification one should set content intent.


//pendingintent is a special token it can be reterived from static methods such  as PendingIntent#getActivity, PendingIntent#getBroadcast #PedningInent#getService etc. to start service or send  broadcast.


Intent intent = new Intent(this, AlertDetails.class);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        // Set the intent that will fire when the user taps the notification
        .setContentIntent(pendingIntent)
        .setAutoCancel(true);


5) Add action buttons

A notification can offer up to three action buttons that allow the user to respond quickly, such as snooze a reminder or even reply to a text message. 
But these action buttons should not duplicate the action performed when the user taps the notification.

To add an action button, pass a PendingIntent to the addAction() method. 
This is just like setting up the notification's default tap action, except instead of launching an activity, 
you can do a variety of other things such as start a BroadcastReceiver that performs a job in the background so the action does not interrupt the app that's already open.



<Code>

Intent snoozeIntent = new Intent(this, MyBroadcastReceiver.class);
snoozeIntent.setAction(ACTION_SNOOZE);
snoozeIntent.putExtra(EXTRA_NOTIFICATION_ID, 0);
PendingIntent snoozePendingIntent =
        PendingIntent.getBroadcast(this, 0, snoozeIntent, 0);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        .setContentIntent(pendingIntent)
        .addAction(R.drawable.ic_snooze, getString(R.string.snooze),	 	// adding the PendingIntent instance in the addAction() method.
                snoozePendingIntent);



10:14 AM 9/5/2019

Since Android 0 release we can't show notification  by normal way
Notification channels enables us app developer to group our notification into group - channels
with the user having the ability to modify notification setting
Ex:- For each channel user can block all notification or allow notification to show.



=> Add a DIrect reply action :---------------------
The direct reply action introduced in ANdroid &.0 (API Level 24) allows uses to enter text directly into the notification which is delivered to your app without opening an activity.
You can use a direct reply action to let user reply to text message or update taks list from wihtin notificaiton.

Add the reply button

1) create an instance of RemoteInput.Builder that you add to your notification action. This class's constructor accepts a string that the system uses as the key for the text input

private static final String KEY_TEXT_REPLY="key_text_reply";
String replyLabel=getresource().getString(R.string.reply_label);
RemoteInput remoteInput=new RemoteInput.Builder(KEY_TEXT_REPLY)
.setLabel(replyLabel)
.build();

2) Create PendingIntent for the reply action

PendingIntent replyPendingIntent=PendingIntent.getBroadcast(getApplicationContext(), conversation.getConversationId(), getMessageReplyIntent(conversation.getConversationId()),PendingIntent.FLAG_UPDATE_CURRENT);


3) Attach the RemoteInput object to an action using addRemoteInput()
//create the reply action and add the remote input

NotificationCompat.Action action=new NotificationCompat.Action.Builder(R.drawable.ic__reply_icon,getString(R.string.label),replyPendingIntent)
.addRemoteInput(remoteInput)
.build();


4) Apply the action to a notification and issue the notificaiton

Notification newMessageNotification = new Notification.Builder(context,CHANNEL_ID)
.setSmallIcon(R.drawble.icon_message)
.setContentTitle(getString(R.string.title))
.setContentText(getString(R.string.content))
.addAction(action)
.build()

//Issue Notification
NotificationManagerCompat notificatioManager=NotificationManagerCompat.from(this);
notificationManager.notify(notificationId,newMessageNotification)



=> Reterieve user input from reply :-------------------

To receive user input from the notification's reply UI call RemoteInput.getResultsFromIntent() passing it the Intent received by your BroadcastReceiver

private ChaSequence getMessageText(Intent intent)
{
	Bundle remoteInput=RemoteInput.getResultsFromIntent(intent);
	if(remoteInput!=null)
	{
		return remoteInput.getCharSequence(KEY_TEXT_REPLY);
	}
	return NULL;
}



After you’ve processed the text, you must update the notification by calling NotificationManagerCompat.notify() with the same ID and tag (if used). This is necessary to hide direct reply 
UI and confirm to the user that their reply was received and processed correctly.

// Build a new notification, which informs the user that the system
// handled their interaction with the previous notification.
Notification repliedNotification = new Notification.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.ic_message)
        .setContentText(getString(R.string.replied))
        .build();	//here we use notification builder to set various notification properties like its small and large icons title priority etc.

// Issue the new notification.
NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
notificationManager.notify(notificationId, repliedNotification);





=> Set a system-wide category :--------------------

Android uses a some pre-defined system-wide categories to determine whether to distrub the user with a given notification when the user has enable Do Not Disturb mode.

if your notification falls into one of the pre-defined notification categories deined in NotificationCompat  such as  CATEGORY_ALARM, CATEGORY_REMINDER, CATEROY_EVENT or CATEGORY_CALL
you should declared it as such by passing the appropriate category to setCategory().

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)		// to set the priority
        .setCategory(NotificationCompat.CATEGORY_MESSAGE);  // use to set  when to interact with the user category


=> Show an Urgent Message :----------

Your app might need to display an urgent time-sensitive message such as an incoming phone call or a ringing alarm. In these situation you can associate a full-screen intent with your notification
When the notification is invoked users see one of the following depending on the device's lock status.

If the user's device is locked, a full-screen activity appears, covering the lockscreen.
If the user's device is unlocked, the notification appears in an expanded form that includes options for handling or dismissing the notification.

Intent fullScreenIntent = new Intent(this, ImportantActivity.class);
PendingIntent fullScreenPendingIntent = PendingIntent.getActivity(this, 0,
        fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle("My notification")
        .setContentText("Hello World!")
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
        .setFullScreenIntent(fullScreenPendingIntent, true);



=> Set lock screen visibility

To control the level of detail visible in the notification from the lock screen, call setVisibility() and specify one of the following values:

VISIBILITY_PUBLIC shows the notification's full content.
VISIBILITY_SECRET doesn't show any part of this notification on the lock screen.
VISIBILITY_PRIVATE shows basic information, such as the notification's icon and the content title, but hides the notification's full content.

When VISIBILITY_PRIVATE is set, you can also provide an alternate version of the notification content which hides certain details. 
For example, an SMS app might display a notification that shows You have 3 new text messages, but hides the message contents and senders. 
To provide this alternative notification, first create the alternative notification with NotificationCompat.Builder as usual. 
Then attach the alternative notification to the normal notification with setPublicVersion().


=> Create a Expandable Notification :------------------

To start, build a notification with all the basic content as described in Create a Notification. Then, call setStyle() with a style object and supply information corresponding to each template

1) Add a Large Image
Notification notification=new NotificationCompat.Builder(context,CHANNEL_ID);  //because in notification class all the setStyle() method are define
.setSmallIcon(R.drawable.new_post)
.setContentTitle(imageTitle)
.setContextText(imageDescription)
.setStyle(new NotificationCompat.BigPictureStyle().bigPicture(myBitmap))
.build()


to make the image appear as a thumbnail only while the notification is collapse call setLargeIcon() and pass it the image, but also call BigPictureStyle.bigLargeIcon() and pass it 
null so the large icon goes away when the notification is expanded:

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_post)
        .setContentTitle(imageTitle)
        .setContentText(imageDescription)
        .setLargeIcon(myBitmap)
        .setStyle(new NotificationCompat.BigPictureStyle()
                .bigPicture(myBitmap)
                .bigLargeIcon(null))
        .build();



=> Add  a large block of text :----------

Apply NotificationCompat.BigTextStyle to display text in the expanded content area of the notification.

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_mail)
        .setContentTitle(emailObject.getSenderName())
        .setContentText(emailObject.getSubject())
        .setLargeIcon(emailObject.getSenderAvatar())
        .setStyle(new NotificationCompat.BigTextStyle()			// BigTextStyle to display text in the expanded content area of notification
                .bigText(emailObject.getSubjectAndSnippet()))
        .build();





=> Create an Inbox-style Notification :------------------

Apply NotificationCompat.InboxStyle to notification if you want to add multiple short summary line such as snippets from incoming emails.This allows you to add multiple pieces of content text
 that are truncated to one line instead of one continues line of text provided by NotificationCompat.BigTextStyle.

to add a new line call addLine() up to 6 times if you add more than 6 lines only the first 6 are visible.

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_mail)
        .setContentTitle("5 New mails from " + sender.toString())
        .setContentText(subject)
        .setLargeIcon(aBitmap)
        .setStyle(new NotificationCompat.InboxStyle()
                .addLine(messageSnippet1)
                .addLine(messageSnippet2))
        .build();




=> Show a conversation in a notification :-
Apply NotificationCompat.MessagingStyle to display sequential messages between any number of people. This is ideal for messaging apps because it provides a consistent layout for 
each message by handling the sender name and message text separately, and each message can be multiple lines long.

NotificationCompat.MessagingStyle.Message message1 =
        new NotificationCompat.MessagingStyle.Message(messages[0].getText(),
                                                      messages[0].getTime(),
                                                      messages[0].getSender());
NotificationCompat.MessagingStyle.Message message2 =
        new NotificationCompat.MessagingStyle.Message(messages[1].getText(),
                                                      messages[1].getTime(),
                                                      messages[1].getSender());

Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_message)
        .setStyle(new NotificationCompat.MessagingStyle(resources.getString(R.string.reply_name))
                .addMessage(message1)
                .addMessage(message2))
        .build();
















	Drawable resource :---------------

A drawablw resource is a general concept for a graphics that can be drawn to the screen and which you can reterieve with APIs such as getDrawable(int) or apply to another Xml resource 
attributes such as android:drawable and android:icon

Different types of Drawable :-

1) Bitmap		:- a bitmap graphics file (.png, .jgp, or .gif) create a BitmapDrawable
2) Nine-patch File	:- A PNG file with stretchable region to allow image resizing on content
3) Layer List	:- A drawable that manage an array of other Drawables .these are drawn in array order so the element with the largest index is be drawn on top.
4) State List	:- an Xml file that reference different bitmap graphics for different states (for example to use a different image when a button is pressed)
5) Level List	:- an Xml file that defines a drawable that manges a number of alternative Drawable each assign a maximum numerical value.
6) Transition Drawable :-  an xml file that define a drawable that can cross fade between two drawable resource.
7) Inset Drawable	:- an sml file that define drawable that insets another drawable by a specific distane.
8)clip drawable	:- an xml file that define a drawable that clip another drawabable
9) Scale Drawable	:- an xml file that define a drawable that change the size of another drawable


A bitmap file is a .png, .jpg, or .gif file. Android creates a Drawable resource for any of these files when you save them in the res/drawable/ directory.

resource reference:
In Java: R.drawable.filename
In XML: @[package:]drawable/filename